{
  "version": 3,
  "sources": ["../src/index.ts", "../src/attributes/guards/guardUnsatisifedException.ts", "../src/attributes/guards/guardPath.ts", "../src/state.ts", "../src/nodes/node.ts", "../src/nodes/leaf/leaf.ts", "../src/lookup.ts", "../src/nodes/leaf/action.ts", "../src/nodes/leaf/condition.ts", "../src/nodes/leaf/wait.ts", "../src/nodes/decorator/decorator.ts", "../src/nodes/decorator/root.ts", "../src/nodes/decorator/repeat.ts", "../src/nodes/decorator/retry.ts", "../src/nodes/decorator/flip.ts", "../src/nodes/decorator/succeed.ts", "../src/nodes/decorator/fail.ts", "../src/nodes/composite/composite.ts", "../src/nodes/composite/lotto.ts", "../src/nodes/composite/selector.ts", "../src/nodes/composite/sequence.ts", "../src/nodes/composite/parallel.ts", "../src/attributes/attribute.ts", "../src/attributes/guards/guard.ts", "../src/attributes/guards/while.ts", "../src/attributes/guards/until.ts", "../src/attributes/callbacks/callback.ts", "../src/attributes/callbacks/entry.ts", "../src/attributes/callbacks/exit.ts", "../src/attributes/callbacks/step.ts", "../src/rootAstNodesBuilder.ts", "../src/behaviourTree.ts"],
  "sourcesContent": ["import BehaviourTree from \"./behaviourTree\";\nimport State from \"./state\";\n\nexport { BehaviourTree, State };\n", "/**\n * An exception thrown when evaluating node guard path conditions and a conditions fails.\n * @param source The node at which a guard condition failed.\n */\nexport default class GuardUnsatisifedException extends Error {\n    constructor(private source: any) {\n        super(\"A guard path condition has failed\");\n    }\n\n    /**\n     * Gets whether the specified node is the node at which a guard condition failed.\n     * @param node The node to check against the source node.\n     * @returns Whether the specified node is the node at which a guard condition failed.\n     */\n    isSourceNode = (node:any) => node === this.source;\n}\n", "import GuardUnsatisifedException from \"./guardUnsatisifedException\";\n\n/**\n * Represents a path of node guards along a root-to-leaf tree path.\n * @param nodes An array of objects defining a node instance -> guard link, ordered by node depth.\n */\nexport default class GuardPath {\n    constructor(private nodes: any[]) {}\n\n    /**\n     * Evaluate guard conditions for all guards in the tree path, moving outwards from the root.\n     * @param agent The agent, required for guard evaluation.\n     * @returns An evaluation results object.\n     */\n    evaluate = (agent: any) => {\n        // We need to evaluate guard conditions for nodes up the tree, moving outwards from the root.\n        for (const details of this.nodes) {\n            // There can be multiple guards per node.\n            for (const guard of details.guards) {\n                // Check whether the guard condition passes, and throw an exception if not.\n                if (!guard.isSatisfied(agent)) {\n                    throw new GuardUnsatisifedException(details.node);\n                }\n            }\n        }\n    };\n}\n", "/**\n * Enumeration of node state types.\n */\nconst State = {\n    READY: Symbol(\"mistreevous.ready\"),\n    RUNNING: Symbol(\"mistreevous.running\"),\n    SUCCEEDED: Symbol(\"mistreevous.succeeded\"),\n    FAILED: Symbol(\"mistreevous.failed\")\n};\n\nexport { State as default };\n", "import GuardPath from \"../attributes/guards/guardPath\";\nimport GuardUnsatisifedException from \"../attributes/guards/guardUnsatisifedException\";\nimport State from \"../state\";\nimport Decorator from \"./decorator/decorator\";\nimport Leaf from \"./leaf/leaf\";\n\n/**\n * A base node.\n * @param type The node type.\n * @param decorators The node decorators.\n * @param args The node argument definitions.\n */\nexport default abstract class Node {\n    constructor(private type: string, private decorators: Decorator[] | null, private args: any[]) {}\n    /**\n     * The node uid.\n     */\n    private readonly uid: string = createNodeUid();\n    /**\n     * The node state.\n     */\n    private state: any = State.READY;\n    /**\n     * The guard path to evaluate as part of a node update.\n     */\n    private guardPath: GuardPath | undefined;\n\n    abstract onUpdate: (agent: any) => void;\n    abstract getName: () => string;\n    abstract isLeafNode: () => this is Leaf;\n\n    /**\n     * Gets/Sets the state of the node.\n     */\n    getState = (): any => this.state;\n    setState = (value: any): any => (this.state = value);\n\n    /**\n     * Gets the unique id of the node.\n     */\n    getUid = () => this.uid;\n\n    /**\n     * Gets the type of the node.\n     */\n    getType = () => this.type;\n\n    /**\n     * Gets the node decorators.\n     */\n    getDecorators = () => this.decorators || [];\n\n    /**\n     * Gets the node arguments.\n     */\n    getArguments = () => this.args || [];\n\n    /**\n     * Gets the node decorator with the specified type, or null if it does not exist.\n     */\n    // getDecorator(type: \"entry\"): Entry;\n    // getDecorator(type: \"exit\"): Exit;\n    // getDecorator(type: \"step\"): Step;\n    getDecorator(type: string): Decorator {\n        return this.getDecorators().filter((decorator) => decorator.getType().toUpperCase() === type.toUpperCase())[0] || null;\n    }\n\n    /**\n     * Gets the node decorators.\n     */\n    getGuardDecorators = () => this.getDecorators().filter((decorator) => (decorator as any).isGuard());\n\n    /**\n     * Sets the guard path to evaluate as part of a node update.\n     */\n    setGuardPath = (value: GuardPath) => (this.guardPath = value);\n\n    /**\n     * Gets whether a guard path is assigned to this node.\n     */\n    hasGuardPath = () => !!this.guardPath;\n\n    /**\n     * Gets whether this node is in the specified state.\n     * @param value The value to compare to the node state.\n     */\n    is = (value: any) => this.state === value;\n\n    /**\n     * Reset the state of the node.\n     */\n    reset = () => this.setState(State.READY);\n\n    /**\n     * Abort the running of this node.\n     * @param agent The agent.\n     */\n    abort = (agent: any) => {\n        // There is nothing to do if this node is not in the running state.\n        if (!this.is(State.RUNNING)) {\n            return;\n        }\n\n        // Reset the state of this node.\n        this.reset();\n\n        // Try to get the exit decorator for this node.\n        const exitDecorator = this.getDecorator(\"exit\");\n\n        // Call the exit decorator function if it exists.\n        if (exitDecorator) {\n            (exitDecorator as any).callAgentFunction(agent, false, true);\n        }\n    };\n\n    /**\n     * Update the node.\n     * @param agent The agent.\n     * @returns The result of the update.\n     */\n    update = (agent: any) => {\n        // If this node is already in a 'SUCCEEDED' or 'FAILED' state then there is nothing to do.\n        if (this.is(State.SUCCEEDED) || this.is(State.FAILED)) {\n            // We have not changed state.\n            return {};\n        }\n\n        try {\n            // Evaluate all of the guard path conditions for the current tree path.\n            this.guardPath!.evaluate(agent);\n\n            // If this node is in the READY state then call the ENTRY decorator for this node if it exists.\n            if (this.is(State.READY)) {\n                const entryDecorator = this.getDecorator(\"entry\");\n\n                // Call the entry decorator function if it exists.\n                if (entryDecorator) {\n                    (entryDecorator as any).callAgentFunction(agent);\n                }\n            }\n\n            // Try to get the step decorator for this node.\n            const stepDecorator = this.getDecorator(\"step\");\n\n            // Call the step decorator function if it exists.\n            if (stepDecorator) {\n                (stepDecorator as any).callAgentFunction(agent);\n            }\n\n            // Do the actual update.\n            this.onUpdate(agent);\n\n            // If this node is now in a 'SUCCEEDED' or 'FAILED' state then call the EXIT decorator for this node if it exists.\n            if (this.is(State.SUCCEEDED) || this.is(State.FAILED)) {\n                const exitDecorator = this.getDecorator(\"exit\");\n\n                // Call the exit decorator function if it exists.\n                if (exitDecorator) {\n                    (exitDecorator as any).callAgentFunction(agent, this.is(State.SUCCEEDED), false);\n                }\n            }\n        } catch (error) {\n            // If the error is a GuardUnsatisfiedException then we need to determine if this node is the source.\n            if (error instanceof GuardUnsatisifedException && error.isSourceNode(this)) {\n                // Abort the current node.\n                this.abort(agent);\n\n                // Any node that is the source of an abort will be a failed node.\n                this.setState(State.FAILED);\n            } else {\n                throw error;\n            }\n        }\n    };\n}\n\n/**\n * Create a randomly generated node uid.\n * @returns A randomly generated node uid.\n */\nfunction createNodeUid(): string {\n    var S4 = function () {\n        return (((1 + Math.random()) * 0x10000) | 0).toString(16).substring(1);\n    };\n    return S4() + S4() + \"-\" + S4() + \"-\" + S4() + \"-\" + S4() + \"-\" + S4() + S4() + S4();\n}\n", "import Node from \"../node\";\n\n/**\n * A leaf node.\n * @param type The node type.\n * @param decorators The node decorators.\n * @param args The node argument definitions.\n */\nexport default abstract class Leaf extends Node {\n    /**\n     * Gets whether this node is a leaf node.\n     */\n    isLeafNode = () => true;\n}\n", "export type Arg = {value: any};\nexport type Args = Arg[];\nexport type InvokerFunction<T> = (args: Args) => T;\n\n/**\n * A singleton used to store and lookup registered functions and subtrees.\n */\nexport default class Lookup {\n    /**\n     * The object holding any registered functions keyed on function name.\n     */\n    private static functionTable: {[key: string]: Function} = {};\n    /**\n     * The object holding any registered sub-trees keyed on tree name.\n     */\n    private static subtreeTable: {[key: string]: any} = {};\n\n    /**\n     * Gets the function with the specified name.\n     * @param name The name of the function.\n     * @returns The function with the specified name.\n     */\n    public static getFunc(name: string): Function {\n        return this.functionTable[name];\n    }\n\n    /**\n     * Sets the function with the specified name for later lookup.\n     * @param name The name of the function.\n     * @param func The function.\n     */\n    public static setFunc(name: string, func: Function): void {\n        this.functionTable[name] = func;\n    }\n\n    /**\n     * Gets the function invoker for the specified agent and function name.\n     * If a function with the specified name exists on the agent object then it will\n     * be returned, otherwise we will then check the registered functions for a match.\n     * @param agent The agent instance that this behaviour tree is modelling behaviour for.\n     * @param name The function name.\n     * @returns The function invoker for the specified agent and function name.\n     */\n    static getFuncInvoker<T>(agent: any, name: string): InvokerFunction<T> | null {\n        // Check whether the agent contains the specified function.\n        if (agent[name] && typeof agent[name] === \"function\") {\n            return (args: Args) =>\n                agent[name].apply(\n                    agent,\n                    args.map((arg) => arg.value)\n                );\n        }\n\n        // The agent does not contain the specified function but it may have been registered at some point.\n        if (this.functionTable[name] && typeof this.functionTable[name] === \"function\") {\n            return (args: Args) => this.functionTable[name](agent, ...args.map((arg) => arg.value));\n        }\n\n        // We have no function to invoke.\n        return null;\n    }\n\n    /**\n     * Gets the subtree with the specified name.\n     * @param name The name of the subtree.\n     * @returns The subtree with the specified name.\n     */\n    static getSubtree(name: string) {\n        return this.subtreeTable[name];\n    }\n\n    /**\n     * Sets the subtree with the specified name for later lookup.\n     * @param name The name of the subtree.\n     * @param subtree The subtree.\n     */\n    static setSubtree(name: string, subtree: any) {\n        this.subtreeTable[name] = subtree;\n    }\n\n    /**\n     * Removes the registered function or subtree with the specified name.\n     * @param name The name of the registered function or subtree.\n     */\n    static remove(name: string) {\n        delete this.functionTable[name];\n        delete this.subtreeTable[name];\n    }\n\n    /**\n     * Remove all registered functions and subtrees.\n     */\n    static empty() {\n        this.functionTable = {};\n        this.subtreeTable = {};\n    }\n}\n", "import Leaf from \"./leaf\";\nimport State from \"../../state\";\nimport Lookup, { Args } from \"../../lookup\";\nimport Decorator from \"../decorator/decorator\";\n\n/**\n * An Action leaf node.\n * This represents an immediate or ongoing state of behaviour.\n * @param decorators The node decorators.\n * @param actionName The action name.\n * @param actionArguments The array of action argument definitions.\n */\nexport default class Action extends Leaf {\n    constructor(decorators: Decorator[] | null, private actionName: string, private actionArguments: Args) {\n        super(\"action\", decorators, actionArguments);\n    }\n\n    /**\n     * Whether there is a pending update promise.\n     */\n    private isUsingUpdatePromise = false;\n\n    /**\n     * The finished state result of an update promise.\n     */\n    private updatePromiseStateResult = null;\n\n    /**\n     * Update the node.\n     * @param agent The agent.\n     * @returns The result of the update.\n     */\n    onUpdate = (agent: any) => {\n        // If the result of this action depends on an update promise then there is nothing to do until\n        // it resolves, unless there has been a value set as a result of the update promise resolving.\n        if (this.isUsingUpdatePromise) {\n            // Check whether the update promise has resolved with a state value.\n            if (this.updatePromiseStateResult) {\n                // Set the state of this node to match the state returned by the promise.\n                this.setState(this.updatePromiseStateResult);\n            }\n\n            return;\n        }\n\n        // Attempt to get the invoker for the action function.\n        const actionFuncInvoker = Lookup.getFuncInvoker<Promise<any> | any>(agent, this.actionName);\n\n        // The action function should be defined.\n        if (actionFuncInvoker === null) {\n            throw new Error(\n                `cannot update action node as the action '${this.actionName}' function is not defined on the agent and has not been registered`\n            );\n        }\n\n        // Call the action function, the result of which may be:\n        // - The finished state of this action node.\n        // - A promise to return a finished node state.\n        // - Undefined if the node should remain in the running state.\n        const updateResult = actionFuncInvoker(this.actionArguments);\n\n        if (updateResult instanceof Promise) {\n            updateResult.then(\n                (result) => {\n                    // If 'isUpdatePromisePending' is null then the promise was cleared as it was resolving, probably via an abort of reset.\n                    if (!this.isUsingUpdatePromise) {\n                        return;\n                    }\n\n                    // Check to make sure the result is a valid finished state.\n                    if (result !== State.SUCCEEDED && result !== State.FAILED) {\n                        throw new Error(\n                            \"action node promise resolved with an invalid value, expected a State.SUCCEEDED or State.FAILED value to be returned\"\n                        );\n                    }\n\n                    // Set pending update promise state result to be processed on next update.\n                    this.updatePromiseStateResult = result;\n                },\n                (reason) => {\n                    // If 'isUpdatePromisePending' is null then the promise was cleared as it was resolving, probably via an abort of reset.\n                    if (!this.isUsingUpdatePromise) {\n                        return;\n                    }\n\n                    // Just throw whatever was returned as the rejection argument.\n                    throw new Error(reason);\n                }\n            );\n\n            // This node will be in the 'RUNNING' state until the update promise resolves.\n            this.setState(State.RUNNING);\n\n            // We are now waiting for the promise returned by the use to resolve before we know what state this node is in.\n            this.isUsingUpdatePromise = true;\n        } else {\n            // Validate the returned value.\n            this.validateUpdateResult(updateResult);\n\n            // Set the state of this node, this may be undefined, which just means that the node is still in the 'RUNNING' state.\n            this.setState(updateResult || State.RUNNING);\n        }\n    };\n\n    /**\n     * Gets the name of the node.\n     */\n    getName = () => this.actionName;\n\n    /**\n     * Reset the state of the node.\n     */\n    reset = () => {\n        // Reset the state of this node.\n        this.setState(State.READY);\n\n        // There is no longer an update promise that we care about.\n        this.isUsingUpdatePromise = false;\n        this.updatePromiseStateResult = null;\n    };\n\n    /**\n     * Validate the result of an update function call.\n     * @param result The result of an update function call.\n     */\n    private validateUpdateResult = (result: any) => {\n        switch (result) {\n            case State.SUCCEEDED:\n            case State.FAILED:\n            case undefined:\n                return;\n            default:\n                throw new Error(\n                    `action '${this.actionName}' 'onUpdate' returned an invalid response, expected an optional State.SUCCEEDED or State.FAILED value to be returned`\n                );\n        }\n    };\n}\n", "import Leaf from \"./leaf\";\nimport State from \"../../state\";\nimport Lookup, { Args } from \"../../lookup\";\nimport Decorator from \"../decorator/decorator\";\n\n/**\n * A Condition leaf node.\n * This will succeed or fail immediately based on an agent predicate, without moving to the 'RUNNING' state.\n * @param decorators The node decorators.\n * @param conditionName The name of the condition function.\n * @param conditionArguments The array of condition argument definitions.\n */\nexport default class Condition extends Leaf {\n    constructor(decorators: Decorator[] | null, private conditionName: string, private conditionArguments: Args) {\n        super(\"condition\", decorators, conditionArguments);\n    }\n\n    /**\n     * Update the node.\n     * @param agent The agent.\n     * @returns The result of the update.\n     */\n    onUpdate = (agent: any) => {\n        // Attempt to get the invoker for the condition function.\n        const conditionFuncInvoker = Lookup.getFuncInvoker(agent, this.conditionName);\n\n        // The condition function should be defined.\n        if (conditionFuncInvoker === null) {\n            throw new Error(\n                `cannot update condition node as the condition '${this.conditionName}' function is not defined on the agent and has not been registered`\n            );\n        }\n\n        // Call the condition function to determine the state of this node.\n        this.setState(!!conditionFuncInvoker(this.conditionArguments) ? State.SUCCEEDED : State.FAILED);\n    };\n\n    /**\n     * Gets the name of the node.\n     */\n    getName = () => this.conditionName;\n}\n", "import Leaf from \"./leaf\";\nimport State from \"../../state\";\nimport Decorator from \"../decorator/decorator\";\n\n/**\n * A WAIT node.\n * The state of this node will change to SUCCEEDED after a duration of time.\n * @param decorators The node decorators.\n * @param duration The duration that this node will wait to succeed in milliseconds, or the earliest if longestDuration is defined.\n * @param longestDuration The longest possible duration in milliseconds that this node will wait to succeed.\n */\nexport default class Wait extends Leaf {\n    constructor(decorators: Decorator[] | null, private duration: number, private longestDuration: number) {\n        super(\"wait\", decorators, []);\n    }\n\n    /**\n     * The time in milliseconds at which this node was first updated.\n     */\n    private initialUpdateTime: number | undefined;\n\n    /**\n     * The duration in milliseconds that this node will be waiting for.\n     */\n    private waitDuration: number | undefined;\n\n    /**\n     * Update the node.\n     * @param agent The agent.\n     * @returns The result of the update.\n     */\n    onUpdate = (agent: any) => {\n        // If this node is in the READY state then we need to set the initial update time.\n        if (this.is(State.READY)) {\n            // Set the initial update time.\n            this.initialUpdateTime = new Date().getTime();\n\n            // If a longestDuration value was defined then we will be randomly picking a duration between the\n            // shortest and longest duration. If it was not defined, then we will be just using the duration.\n            this.waitDuration = this.longestDuration\n                ? Math.floor(Math.random() * (this.longestDuration - this.duration + 1) + this.duration)\n                : this.duration;\n\n            // The node is now running until we finish waiting.\n            this.setState(State.RUNNING);\n        }\n\n        // Have we waited long enough?\n        if (new Date().getTime() >= this.initialUpdateTime! + this.waitDuration!) {\n            // We have finished waiting!\n            this.setState(State.SUCCEEDED);\n        }\n    };\n\n    /**\n     * Gets the name of the node.\n     */\n    getName = () => `WAIT ${this.longestDuration ? this.duration + \"ms-\" + this.longestDuration + \"ms\" : this.duration + \"ms\"}`;\n}\n", "import Node from \"../node\";\nimport State from \"../../state\";\n\n/**\n * A decorator node that wraps a single child node.\n * @param type The node type.\n * @param decorators The node decorators.\n * @param child The child node.\n */\nexport default abstract class Decorator extends Node {\n    constructor(type: string, decorators: Decorator[] | null, protected child: Node) {\n        super(type, decorators, []);\n    }\n\n    /**\n     * Gets whether this node is a leaf node.\n     */\n    isLeafNode = () => false;\n\n    /**\n     * Gets the children of this node.\n     */\n    getChildren = () => [this.child];\n\n    /**\n     * Reset the state of the node.\n     */\n    reset = () => {\n        // Reset the state of this node.\n        this.setState(State.READY);\n\n        // Reset the state of the child node.\n        this.child.reset();\n    };\n\n    /**\n     * Abort the running of this node.\n     * @param agent The agent.\n     */\n    abort = (agent: any) => {\n        // There is nothing to do if this node is not in the running state.\n        if (!this.is(State.RUNNING)) {\n            return;\n        }\n\n        // Abort the child node.\n        this.child.abort(agent);\n\n        // Reset the state of this node.\n        this.reset();\n\n        // Try to get the exit decorator for this node.\n        const exitDecorator = this.getDecorator(\"exit\");\n\n        // Call the exit decorator function if it exists.\n        if (exitDecorator) {\n            (exitDecorator as any).callAgentFunction(agent, false, true);\n        }\n    };\n}\n", "import Node from \"../node\";\nimport Decorator from \"./decorator\";\nimport State from \"../../state\";\n\n/**\n * A Root node.\n * The root node will have a single child.\n * @param decorators The node decorators.\n * @param child The child node.\n */\nexport default class Root extends Decorator {\n    constructor(decorators: Decorator[] | null, child: Node) {\n        super(\"root\", decorators, child);\n    }\n\n    /**\n     * Update the node and get whether the node state has changed.\n     * @param agent The agent.\n     * @returns Whether the state of this node has changed as part of the update.\n     */\n    onUpdate = (agent: any) => {\n        // If the child has never been updated or is running then we will need to update it now.\n        if (this.child.getState() === State.READY || this.child.getState() === State.RUNNING) {\n            // Update the child of this node.\n            this.child.update(agent);\n        }\n\n        // The state of the root node is the state of its child.\n        this.setState(this.child.getState());\n    };\n\n    /**\n     * Gets the name of the node.\n     */\n    getName = () => \"ROOT\";\n}\n", "import Node from \"../node\";\nimport Decorator from \"./decorator\";\nimport State from \"../../state\";\n\n/**\n * A REPEAT node.\n * The node has a single child which can have:\n * -- A number of iterations for which to repeat the child node.\n * -- An infinite repeat loop if neither an iteration count or a condition function is defined.\n * The REPEAT node will stop and have a 'FAILED' state if its child is ever in a 'FAILED' state after an update.\n * The REPEAT node will attempt to move on to the next iteration if its child is ever in a 'SUCCEEDED' state.\n * @param decorators The node decorators.\n * @param iterations The number of iterations to repeat the child node, or the minimum number of iterations if maximumIterations is defined.\n * @param maximumIterations The maximum number of iterations to repeat the child node.\n * @param child The child node.\n */\nexport default class Repeat extends Decorator {\n    constructor(decorators: Decorator[] | null, private iterations: number, private maximumIterations: number, child: Node) {\n        super(\"repeat\", decorators, child);\n    }\n\n    /**\n     * The number of target iterations to make.\n     */\n    private targetIterationCount: number | null = null;\n\n    /**\n     * The current iteration count.\n     */\n    private currentIterationCount: number = 0;\n\n    /**\n     * Update the node.\n     * @param agent The agent.\n     * @returns The result of the update.\n     */\n    onUpdate = (agent: any) => {\n        // If this node is in the READY state then we need to reset the child and the target iteration count.\n        if (this.is(State.READY)) {\n            // Reset the child node.\n            this.child.reset();\n\n            // Set the target iteration count.\n            this.setTargetIterationCount();\n        }\n\n        // Do a check to see if we can iterate. If we can then this node will move into the 'RUNNING' state.\n        // If we cannot iterate then we have hit our target iteration count, which means that the node has succeeded.\n        if (this.canIterate()) {\n            // This node is in the running state and can do its initial iteration.\n            this.setState(State.RUNNING);\n\n            // We may have already completed an iteration, meaning that the child node will be in the SUCCEEDED state.\n            // If this is the case then we will have to reset the child node now.\n            if (this.child.getState() === State.SUCCEEDED) {\n                this.child.reset();\n            }\n\n            // Update the child of this node.\n            this.child.update(agent);\n\n            // If the child moved into the FAILED state when we updated it then there is nothing left to do and this node has also failed.\n            // If it has moved into the SUCCEEDED state then we have completed the current iteration.\n            if (this.child.getState() === State.FAILED) {\n                // The child has failed, meaning that this node has failed.\n                this.setState(State.FAILED);\n\n                return;\n            } else if (this.child.getState() === State.SUCCEEDED) {\n                // We have completed an iteration.\n                this.currentIterationCount += 1;\n            }\n        } else {\n            // This node is in the 'SUCCEEDED' state as we cannot iterate any more.\n            this.setState(State.SUCCEEDED);\n        }\n    };\n\n    /**\n     * Gets the name of the node.\n     */\n    getName = () => {\n        if (this.iterations !== null) {\n            return `REPEAT ${this.maximumIterations ? this.iterations + \"x-\" + this.maximumIterations + \"x\" : this.iterations + \"x\"}`;\n        }\n\n        // Return the default repeat node name.\n        return \"REPEAT\";\n    };\n\n    /**\n     * Reset the state of the node.\n     */\n    reset = () => {\n        // Reset the state of this node.\n        this.setState(State.READY);\n\n        // Reset the current iteration count.\n        this.currentIterationCount = 0;\n\n        // Reset the child node.\n        this.child.reset();\n    };\n\n    /**\n     * Gets whether an iteration can be made.\n     * @returns Whether an iteration can be made.\n     */\n    private canIterate = () => {\n        if (this.targetIterationCount !== null) {\n            // We can iterate as long as we have not reached our target iteration count.\n            return this.currentIterationCount < this.targetIterationCount;\n        }\n\n        // If neither an iteration count or a condition function were defined then we can iterate indefinitely.\n        return true;\n    };\n\n    /**\n     * Sets the target iteration count.\n     */\n    private setTargetIterationCount = () => {\n        // Are we dealing with a finite number of iterations?\n        if (typeof this.iterations === \"number\") {\n            // If we have maximumIterations defined then we will want a random iteration count bounded by iterations and maximumIterations.\n            this.targetIterationCount =\n                typeof this.maximumIterations === \"number\"\n                    ? Math.floor(Math.random() * (this.maximumIterations - this.iterations + 1) + this.iterations)\n                    : this.iterations;\n        } else {\n            this.targetIterationCount = null;\n        }\n    };\n}\n", "import Node from \"../node\";\nimport Decorator from \"./decorator\";\nimport State from \"../../state\";\n\n/**\n * A RETRY node.\n * The node has a single child which can have:\n * -- A number of iterations for which to repeat the child node.\n * -- An infinite repeat loop if neither an iteration count or a condition function is defined.\n * The RETRY node will stop and have a 'SUCCEEDED' state if its child is ever in a 'SUCCEEDED' state after an update.\n * The RETRY node will attempt to move on to the next iteration if its child is ever in a 'FAILED' state.\n * @param decorators The node decorators.\n * @param iterations The number of iterations to repeat the child node, or the minimum number of iterations if maximumIterations is defined.\n * @param maximumIterations The maximum number of iterations to repeat the child node.\n * @param child The child node.\n */\nexport default class Retry extends Decorator {\n    constructor(decorators: Decorator[] | null, private iterations: number, private maximumIterations: number, child: Node) {\n        super(\"retry\", decorators, child);\n    }\n\n    /**\n     * The number of target iterations to make.\n     */\n    private targetIterationCount: number | null = null;\n\n    /**\n     * The current iteration count.\n     */\n    private currentIterationCount: number = 0;\n\n    /**\n     * Update the node.\n     * @param agent The agent.\n     * @returns The result of the update.\n     */\n    onUpdate = (agent: any) => {\n        // If this node is in the READY state then we need to reset the child and the target iteration count.\n        if (this.is(State.READY)) {\n            // Reset the child node.\n            this.child.reset();\n\n            // Set the target iteration count.\n            this.setTargetIterationCount();\n        }\n\n        // Do a check to see if we can iterate. If we can then this node will move into the 'RUNNING' state.\n        // If we cannot iterate then we have hit our target iteration count, which means that the node has succeeded.\n        if (this.canIterate()) {\n            // This node is in the running state and can do its initial iteration.\n            this.setState(State.RUNNING);\n\n            // We may have already completed an iteration, meaning that the child node will be in the FAILED state.\n            // If this is the case then we will have to reset the child node now.\n            if (this.child.getState() === State.FAILED) {\n                this.child.reset();\n            }\n\n            // Update the child of this node.\n            this.child.update(agent);\n\n            // If the child moved into the SUCCEEDED state when we updated it then there is nothing left to do and this node has also succeeded.\n            // If it has moved into the FAILED state then we have completed the current iteration.\n            if (this.child.getState() === State.SUCCEEDED) {\n                // The child has succeeded, meaning that this node has succeeded.\n                this.setState(State.SUCCEEDED);\n\n                return;\n            } else if (this.child.getState() === State.FAILED) {\n                // We have completed an iteration.\n                this.currentIterationCount += 1;\n            }\n        } else {\n            // This node is in the 'FAILED' state as we cannot iterate any more.\n            this.setState(State.FAILED);\n        }\n    };\n\n    /**\n     * Gets the name of the node.\n     */\n    getName = () => {\n        if (this.iterations !== null) {\n            return `RETRY ${this.maximumIterations ? this.iterations + \"x-\" + this.maximumIterations + \"x\" : this.iterations + \"x\"}`;\n        }\n\n        // Return the default retry node name.\n        return \"RETRY\";\n    };\n\n    /**\n     * Reset the state of the node.\n     */\n    reset = () => {\n        // Reset the state of this node.\n        this.setState(State.READY);\n\n        // Reset the current iteration count.\n        this.currentIterationCount = 0;\n\n        // Reset the child node.\n        this.child.reset();\n    };\n\n    /**\n     * Gets whether an iteration can be made.\n     * @returns Whether an iteration can be made.\n     */\n    canIterate = () => {\n        if (this.targetIterationCount !== null) {\n            // We can iterate as long as we have not reached our target iteration count.\n            return this.currentIterationCount < this.targetIterationCount;\n        }\n\n        // If neither an iteration count or a condition function were defined then we can iterate indefinitely.\n        return true;\n    };\n\n    /**\n     * Sets the target iteration count.\n     */\n    setTargetIterationCount = () => {\n        // Are we dealing with a finite number of iterations?\n        if (typeof this.iterations === \"number\") {\n            // If we have maximumIterations defined then we will want a random iteration count bounded by iterations and maximumIterations.\n            this.targetIterationCount =\n                typeof this.maximumIterations === \"number\"\n                    ? Math.floor(Math.random() * (this.maximumIterations - this.iterations + 1) + this.iterations)\n                    : this.iterations;\n        } else {\n            this.targetIterationCount = null;\n        }\n    };\n}\n", "import Decorator from \"./decorator\";\nimport State from \"../../state\";\nimport Node from \"../node\";\n\n/**\n * A Flip node.\n * This node wraps a single child and will flip the state of the child state.\n * @param decorators The node decorators.\n * @param child The child node.\n */\nexport default class Flip extends Decorator {\n    constructor(decorators: Decorator[] | null, child: Node) {\n        super(\"flip\", decorators, child)\n    }\n\n    /**\n     * Update the node.\n     * @param agent The agent.\n     * @returns The result of the update.\n     */\n    onUpdate = (agent: any) => {\n        // If the child has never been updated or is running then we will need to update it now.\n        if (this.child.getState() === State.READY || this.child.getState() === State.RUNNING) {\n            this.child.update(agent);\n        }\n\n        // The state of this node will depend in the state of its child.\n        switch (this.child.getState()) {\n            case State.RUNNING:\n                this.setState(State.RUNNING);\n                break;\n\n            case State.SUCCEEDED:\n                this.setState(State.FAILED);\n                break;\n\n            case State.FAILED:\n                this.setState(State.SUCCEEDED);\n                break;\n\n            default:\n                this.setState(State.READY);\n        }\n    };\n\n    /**\n     * Gets the name of the node.\n     */\n    getName = () => \"FLIP\";\n}\n", "import Node from \"../node\";\nimport Decorator from \"./decorator\";\nimport State from \"../../state\";\n\n/**\n * A Succeed node.\n * This node wraps a single child and will always move to the 'SUCCEEDED' state when the child moves to a 'SUCCEEDED' or 'FAILED' state.\n * @param decorators The node decorators.\n * @param child The child node.\n */\nexport default class Succeed extends Decorator {\n    constructor(decorators: Decorator[] | null, child: Node) {\n        super(\"succeed\", decorators, child);\n    }\n\n    /**\n     * Update the node.\n     * @param agent The agent.\n     * @returns The result of the update.\n     */\n    onUpdate = (agent: any) => {\n        // If the child has never been updated or is running then we will need to update it now.\n        if (this.child.getState() === State.READY || this.child.getState() === State.RUNNING) {\n            this.child.update(agent);\n        }\n\n        // The state of this node will depend in the state of its child.\n        switch (this.child.getState()) {\n            case State.RUNNING:\n                this.setState(State.RUNNING);\n                break;\n\n            case State.SUCCEEDED:\n            case State.FAILED:\n                this.setState(State.SUCCEEDED);\n                break;\n\n            default:\n                this.setState(State.READY);\n        }\n    };\n\n    /**\n     * Gets the name of the node.\n     */\n    getName = () => \"SUCCEED\";\n}\n", "import Node from \"../node\";\nimport Decorator from \"./decorator\";\nimport State from \"../../state\";\n\n/**\n * A Fail node.\n * This node wraps a single child and will always move to the 'FAILED' state when the child moves to a 'SUCCEEDED' or 'FAILED' state.\n * @param decorators The node decorators.\n * @param child The child node.\n */\nexport default class Fail extends Decorator {\n    constructor(decorators: Decorator[] | null, child: Node) {\n        super(\"fail\", decorators, child);\n    }\n\n    /**\n     * Update the node.\n     * @param agent The agent.\n     * @returns The result of the update.\n     */\n    onUpdate = (agent: any) => {\n        // If the child has never been updated or is running then we will need to update it now.\n        if (this.child.getState() === State.READY || this.child.getState() === State.RUNNING) {\n            this.child.update(agent);\n        }\n\n        // The state of this node will depend in the state of its child.\n        switch (this.child.getState()) {\n            case State.RUNNING:\n                this.setState(State.RUNNING);\n                break;\n\n            case State.SUCCEEDED:\n            case State.FAILED:\n                this.setState(State.FAILED);\n                break;\n\n            default:\n                this.setState(State.READY);\n        }\n    };\n\n    /**\n     * Gets the name of the node.\n     */\n    getName = () => \"FAIL\";\n}\n", "import Node from \"../node\";\nimport State from \"../../state\";\nimport Decorator from \"../decorator/decorator\";\n\n/**\n * A composite node that wraps child nodes.\n * @param type The node type.\n * @param decorators The node decorators.\n * @param children The child nodes.\n */\nexport default abstract class Composite extends Node {\n    constructor(type: string, decorators: Decorator[] | null, protected children: Node[]) {\n        super(type, decorators, []);\n    }\n\n    /**\n     * Gets whether this node is a leaf node.\n     */\n    isLeafNode = () => false;\n\n    /**\n     * Gets the children of this node.\n     */\n    getChildren = () => this.children;\n\n    /**\n     * Reset the state of the node.\n     */\n    reset = () => {\n        // Reset the state of this node.\n        this.setState(State.READY);\n\n        // Reset the state of any child nodes.\n        this.getChildren().forEach((child) => child.reset());\n    };\n\n    /**\n     * Abort the running of this node.\n     * @param agent The agent.\n     */\n    abort = (agent: any) => {\n        // There is nothing to do if this node is not in the running state.\n        if (!this.is(State.RUNNING)) {\n            return;\n        }\n\n        // Abort any child nodes.\n        this.getChildren().forEach((child) => child.abort(agent));\n\n        // Reset the state of this node.\n        this.reset();\n\n        // Try to get the exit decorator for this node.\n        const exitDecorator = this.getDecorator(\"exit\");\n\n        // Call the exit decorator function if it exists.\n        if (exitDecorator) {\n            (exitDecorator as any).callAgentFunction(agent, false, true);\n        }\n    };\n}\n", "import Node from \"../node\";\nimport Composite from \"./composite\";\nimport State from \"../../state\";\nimport Decorator from \"../decorator/decorator\";\n\n/**\n * A LOTTO node.\n * A winning child is picked on the initial update of this node, based on ticket weighting.\n * The state of this node will match the state of the winning child.\n * @param decorators The node decorators.\n * @param tickets The child node tickets\n * @param children The child nodes.\n */\nexport default class Lotto extends Composite {\n    constructor(decorators: Decorator[] | null, private tickets: any[], children: Node[]) {\n        super(\"lotto\", decorators, children);\n    }\n\n    /**\n     * The winning child node.\n     */\n    private winningChild: any;\n\n    /**\n     * Update the node and get whether the node state has changed.\n     * @param agent The agent.\n     * @returns Whether the state of this node has changed as part of the update.\n     */\n    onUpdate = (agent: any) => {\n        // If this node is in the READY state then we need to pick a winning child node.\n        if (this.is(State.READY)) {\n            // Create a lotto draw.\n            const lottoDraw = new LottoDraw();\n\n            // Add each child of this node to a lotto draw, with each child's corresponding ticket weighting, or a single ticket if not defined.\n            this.children.forEach((child, index) => lottoDraw.add(child, this.tickets[index] || 1));\n\n            // Randomly pick a child based on ticket weighting.\n            this.winningChild = lottoDraw.draw();\n        }\n\n        // If the winning child has never been updated or is running then we will need to update it now.\n        if (this.winningChild.getState() === State.READY || this.winningChild.getState() === State.RUNNING) {\n            this.winningChild.update(agent);\n        }\n\n        // The state of the lotto node is the state of its winning child.\n        this.setState(this.winningChild.getState());\n    };\n\n    /**\n     * Gets the name of the node.\n     */\n    getName = () => (this.tickets.length ? `LOTTO [${this.tickets.join(\",\")}]` : \"LOTTO\")\n}\n\n/**\n * Represents a lotto draw.\n */\nclass LottoDraw {\n    /**\n     * The participants\n     */\n    private readonly participants: { participant: any, tickets: any }[] = [];\n\n    /**\n     * Add a participant.\n     * @param participant The participant.\n     * @param tickets The number of tickets held by the participant.\n     */\n    add = (participant: any, tickets: any) => {\n        this.participants.push({ participant, tickets });\n        return this;\n    };\n\n    /**\n     * Draw a winning participant.\n     * @returns A winning participant.\n     */\n    draw = () => {\n        // We cannot do anything if there are no participants.\n        if (!this.participants.length) {\n            throw new Error(\"cannot draw a lotto winner when there are no participants\");\n        }\n\n        const pickable: any[] = [];\n\n        this.participants.forEach(({ participant, tickets }) => {\n            for (let ticketCount = 0; ticketCount < tickets; ticketCount++) {\n                pickable.push(participant);\n            }\n        });\n\n        return this.getRandomItem(pickable);\n    };\n\n    /**\n     * Get a random item form an array.\n     * @param items Th array of items.\n     * @returns The randomly picked item.\n     */\n    getRandomItem = (items: any[]) => {\n        // We cant pick a random item from an empty array.\n        if (!items.length) {\n            return undefined;\n        }\n\n        // Return a random item.\n        return items[Math.floor(Math.random() * items.length)];\n    };\n}\n", "import Composite from \"./composite\";\nimport Node from \"../node\";\nimport State from \"../../state\";\nimport Decorator from \"../decorator/decorator\";\n\n/**\n * A SELECTOR node.\n * The child nodes are executed in sequence until one succeeds or all fail.\n * @param decorators The node decorators.\n * @param children The child nodes.\n */\nexport default class Selector extends Composite {\n    constructor(decorators: Decorator[] | null, protected children: Node[]) {\n        super(\"selector\", decorators, children);\n    }\n\n    /**\n     * Update the node and get whether the node state has changed.\n     * @param agent The agent.\n     * @returns Whether the state of this node has changed as part of the update.\n     */\n    onUpdate = (agent: any) => {\n        // Iterate over all of the children of this node.\n        for (const child of this.children) {\n            // If the child has never been updated or is running then we will need to update it now.\n            if (child.getState() === State.READY || child.getState() === State.RUNNING) {\n                // Update the child of this node.\n                child.update(agent);\n            }\n\n            // If the current child has a state of 'SUCCEEDED' then this node is also a 'SUCCEEDED' node.\n            if (child.getState() === State.SUCCEEDED) {\n                // This node is a 'SUCCEEDED' node.\n                this.setState(State.SUCCEEDED);\n\n                // There is no need to check the rest of the selector nodes.\n                return;\n            }\n\n            // If the current child has a state of 'FAILED' then we should move on to the next child.\n            if (child.getState() === State.FAILED) {\n                // Find out if the current child is the last one in the selector.\n                // If it is then this sequence node has also failed.\n                if (this.children.indexOf(child) === this.children.length - 1) {\n                    // This node is a 'FAILED' node.\n                    this.setState(State.FAILED);\n\n                    // There is no need to check the rest of the selector as we have completed it.\n                    return;\n                } else {\n                    // The child node failed, try the next one.\n                    continue;\n                }\n            }\n\n            // The node should be in the 'RUNNING' state.\n            if (child.getState() === State.RUNNING) {\n                // This node is a 'RUNNING' node.\n                this.setState(State.RUNNING);\n\n                // There is no need to check the rest of the selector as the current child is still running.\n                return;\n            }\n\n            // The child node was not in an expected state.\n            throw new Error(\"child node was not in an expected state.\");\n        }\n    };\n\n    /**\n     * Gets the name of the node.\n     */\n    getName = () => \"SELECTOR\";\n}\n", "import Composite from \"./composite\";\nimport Node from \"../node\";\nimport State from \"../../state\";\nimport Decorator from \"../decorator/decorator\";\n\n/**\n * A SEQUENCE node.\n * The child nodes are executed in sequence until one fails or all succeed.\n * @param decorators The node decorators.\n * @param children The child nodes.\n */\nexport default class Sequence extends Composite {\n    constructor(decorators: Decorator[] | null, protected children: Node[]) {\n        super(\"sequence\", decorators, children);\n    }\n\n    /**\n     * Update the node and get whether the node state has changed.\n     * @param agent The agent.\n     * @returns Whether the state of this node has changed as part of the update.\n     */\n    onUpdate = (agent: any) => {\n        // Iterate over all of the children of this node.\n        for (const child of this.children) {\n            // If the child has never been updated or is running then we will need to update it now.\n            if (child.getState() === State.READY || child.getState() === State.RUNNING) {\n                // Update the child of this node.\n                child.update(agent);\n            }\n\n            // If the current child has a state of 'SUCCEEDED' then we should move on to the next child.\n            if (child.getState() === State.SUCCEEDED) {\n                // Find out if the current child is the last one in the sequence.\n                // If it is then this sequence node has also succeeded.\n                if (this.children.indexOf(child) === this.children.length - 1) {\n                    // This node is a 'SUCCEEDED' node.\n                    this.setState(State.SUCCEEDED);\n\n                    // There is no need to check the rest of the sequence as we have completed it.\n                    return;\n                } else {\n                    // The child node succeeded, but we have not finished the sequence yet.\n                    continue;\n                }\n            }\n\n            // If the current child has a state of 'FAILED' then this node is also a 'FAILED' node.\n            if (child.getState() === State.FAILED) {\n                // This node is a 'FAILED' node.\n                this.setState(State.FAILED);\n\n                // There is no need to check the rest of the sequence.\n                return;\n            }\n\n            // The node should be in the 'RUNNING' state.\n            if (child.getState() === State.RUNNING) {\n                // This node is a 'RUNNING' node.\n                this.setState(State.RUNNING);\n\n                // There is no need to check the rest of the sequence as the current child is still running.\n                return;\n            }\n\n            // The child node was not in an expected state.\n            throw new Error(\"child node was not in an expected state.\");\n        }\n    };\n\n    /**\n     * Gets the name of the node.\n     */\n    getName = () => \"SEQUENCE\";\n}\n", "import Composite from \"./composite\";\nimport State from \"../../state\";\nimport Decorator from \"../decorator/decorator\";\nimport Node from \"../node\";\n\n/**\n * A PARALLEL node.\n * The child nodes are executed concurrently until one fails or all succeed.\n * @param decorators The node decorators.\n * @param children The child nodes.\n */\nexport default class Parallel extends Composite {\n    constructor(decorators: Decorator[] | null, children: Node[]) {\n        super(\"parallel\", decorators, children);\n    }\n\n    /**\n     * Update the node and get whether the node state has changed.\n     * @param agent The agent.\n     * @returns Whether the state of this node has changed as part of the update.\n     */\n    onUpdate = (agent: any) => {\n        // Keep a count of the number of succeeded child nodes.\n        let succeededCount = 0;\n\n        let hasChildFailed = false;\n\n        // Iterate over all of the children of this node.\n        for (const child of this.children) {\n            // If the child has never been updated or is running then we will need to update it now.\n            if (child.getState() === State.READY || child.getState() === State.RUNNING) {\n                // Update the child of this node.\n                child.update(agent);\n            }\n\n            // If the current child has a state of 'SUCCEEDED' then we should move on to the next child.\n            if (child.getState() === State.SUCCEEDED) {\n                // The child node has succeeded, keep track of this to determine if all children have.\n                succeededCount++;\n\n                // The child node succeeded, but we have not finished checking every child node yet.\n                continue;\n            }\n\n            // If the current child has a state of 'FAILED' then this node is also a 'FAILED' node.\n            if (child.getState() === State.FAILED) {\n                hasChildFailed = true;\n\n                // There is no need to check the rest of the children.\n                break;\n            }\n\n            // The node should be in the 'RUNNING' state.\n            if (child.getState() !== State.RUNNING) {\n                // The child node was not in an expected state.\n                throw new Error(\"child node was not in an expected state.\");\n            }\n        }\n\n        if (hasChildFailed) {\n            // This node is a 'FAILED' node.\n            this.setState(State.FAILED);\n\n            // Abort every running child.\n            for (const child of this.children) {\n                if (child.getState() === State.RUNNING) {\n                    child.abort(agent);\n                }\n            }\n        } else {\n            // If all children have succeeded then this node has also succeeded, otherwise it is still running.\n            this.setState(succeededCount === this.children.length ? State.SUCCEEDED : State.RUNNING);\n        }\n    };\n\n    /**\n     * Gets the name of the node.\n     */\n    getName = () => \"PARALLEL\";\n}\n", "/**\n * A base node attribute.\n * @param type The node attribute type.\n * @param args The array of attribute argument definitions.\n */\nexport default abstract class Attribute {\n    constructor(protected type: string, protected args: any[]) {}\n    /**\n     * Gets the type of the attribute.\n     */\n    getType = () => this.type;\n\n    /**\n     * Gets the array of attribute argument definitions.\n     */\n    getArguments = () => this.args;\n\n    /**\n     * Gets the attribute details.\n     */\n    getDetails = () => ({\n        type: this.getType(),\n        arguments: this.getArguments()\n    });\n}\n", "import Attribute from \"../attribute\";\n\n/**\n * A base node guard attribute.\n * @param type The node guard attribute type.\n * @param args The array of attribute argument definitions.\n */\nexport default abstract class Guard extends Attribute {\n    /**\n     * Gets whether this attribute is a guard.\n     */\n    isGuard = () => true;\n\n    abstract isSatisfied(agent: any): boolean\n}\n", "import Guard from \"./guard\";\nimport Lookup from \"../../lookup\";\n\n/**\n * A WHILE guard which is satisfied as long as the given condition remains true.\n * @param condition The name of the condition function that determines whether the guard is satisfied.\n * @param args The array of decorator argument definitions.\n */\nexport default class While extends Guard {\n    constructor(private condition: string, args: any[]) {\n        super(\"while\", args);\n    }\n\n    /**\n     * Gets whether the decorator is a guard.\n     */\n    isGuard = () => true;\n\n    /**\n     * Gets the condition of the guard.\n     */\n    getCondition = () => this.condition;\n\n    /**\n     * Gets the decorator details.\n     */\n    getDetails = () => {\n        return {\n            type: this.getType(),\n            isGuard: this.isGuard(),\n            condition: this.getCondition(),\n            arguments: this.getArguments()\n        };\n    };\n\n    /**\n     * Gets whether the guard is satisfied.\n     * @param agent The agent.\n     * @returns Whether the guard is satisfied.\n     */\n    isSatisfied = (agent: any) => {\n        // Attempt to get the invoker for the condition function.\n        const conditionFuncInvoker = Lookup.getFuncInvoker(agent, this.condition);\n\n        // The condition function should be defined.\n        if (conditionFuncInvoker === null) {\n            throw new Error(\n                `cannot evaluate node guard as the condition '${this.condition}' function is not defined on the agent and has not been registered`\n            );\n        }\n\n        // Call the condition function to determine whether this guard is satisfied.\n        return !!conditionFuncInvoker(this.args);\n    };\n}\n", "import Guard from \"./guard\";\nimport Lookup from \"../../lookup\";\n\n/**\n * An UNTIL guard which is satisfied as long as the given condition remains false.\n * @param condition The name of the condition function that determines whether the guard is satisfied.\n * @param args The array of decorator argument definitions.\n */\nexport default class Until extends Guard {\n    constructor(private condition: string, args: any[]) {\n        super(\"until\", args);\n    }\n\n    /**\n     * Gets whether the decorator is a guard.\n     */\n    isGuard = () => true;\n\n    /**\n     * Gets the condition of the guard.\n     */\n    getCondition = () => this.condition;\n\n    /**\n     * Gets the decorator details.\n     */\n    getDetails = () => {\n        return {\n            type: this.getType(),\n            isGuard: this.isGuard(),\n            condition: this.getCondition(),\n            arguments: this.getArguments()\n        };\n    };\n\n    /**\n     * Gets whether the guard is satisfied.\n     * @param agent The agent.\n     * @returns Whether the guard is satisfied.\n     */\n    isSatisfied = (agent: any) => {\n        // Attempt to get the invoker for the condition function.\n        const conditionFuncInvoker = Lookup.getFuncInvoker(agent, this.condition);\n\n        // The condition function should be defined.\n        if (conditionFuncInvoker === null) {\n            throw new Error(\n                `cannot evaluate node guard as the condition '${this.condition}' function is not defined on the agent and has not been registered`\n            );\n        }\n\n        // Call the condition function to determine whether this guard is satisfied.\n        return !!!conditionFuncInvoker(this.args);\n    };\n}\n", "import Attribute from \"../attribute\";\n\n/**\n * A base node callback attribute.\n * @param type The node callback attribute type.\n * @param args The array of attribute argument definitions.\n */\nexport default abstract class Callback extends Attribute {\n    /**\n     * Gets whether this attribute is a guard.\n     */\n    isGuard = () => false;\n\n    abstract callAgentFunction: (agent: any, isSuccess: boolean, isAborted: boolean) => void;\n}\n", "import Callback from \"./callback\";\nimport Lookup from \"../../lookup\";\n\n/**\n * An ENTRY callback which defines an agent function to call when the associated node is updated and moves out of running state.\n * @param functionName The name of the agent function to call.\n * @param args The array of callback argument definitions.\n */\nexport default class Entry extends Callback {\n    constructor(private functionName: string, args: any[]) {\n        super(\"entry\", args);\n    }\n\n    /**\n     * Gets the function name.\n     */\n    getFunctionName = () => this.functionName;\n\n    /**\n     * Gets the callback details.\n     */\n    getDetails = () => {\n        return {\n            type: this.getType(),\n            isGuard: this.isGuard(),\n            functionName: this.getFunctionName(),\n            arguments: this.getArguments()\n        };\n    };\n\n    /**\n     * Attempt to call the agent function that this callback refers to.\n     * @param agent The agent.\n     */\n    callAgentFunction = (agent: any) => {\n        // Attempt to get the invoker for the callback function.\n        const callbackFuncInvoker = Lookup.getFuncInvoker(agent, this.functionName);\n\n        // The callback function should be defined.\n        if (callbackFuncInvoker === null) {\n            throw new Error(\n                `cannot call entry function '${this.functionName}' as is not defined on the agent and has not been registered`\n            );\n        }\n\n        // Call the callback function.\n        callbackFuncInvoker(this.args);\n    };\n}\n", "import Callback from \"./callback\";\nimport Lookup from \"../../lookup\";\n\n/**\n * An EXIT callback which defines an agent function to call when the associated node is updated and moves to a finished state or is aborted.\n * @param functionName The name of the agent function to call.\n * @param args The array of callback argument definitions.\n */\nexport default class Exit extends Callback {\n    constructor(private functionName: string, args: any[]) {\n        super(\"exit\", args);\n    }\n\n    /**\n     * Gets the function name.\n     */\n    getFunctionName = () => this.functionName;\n\n    /**\n     * Gets the callback details.\n     */\n    getDetails = () => {\n        return {\n            type: this.getType(),\n            isGuard: this.isGuard(),\n            functionName: this.getFunctionName(),\n            arguments: this.getArguments()\n        };\n    };\n\n    /**\n     * Attempt to call the agent function that this callback refers to.\n     * @param agent The agent.\n     * @param isSuccess Whether the decorated node was left with a success state.\n     * @param isAborted Whether the decorated node was aborted.\n     */\n    callAgentFunction = (agent: any, isSuccess: boolean, isAborted: boolean) => {\n        // Attempt to get the invoker for the callback function.\n        const callbackFuncInvoker = Lookup.getFuncInvoker(agent, this.functionName);\n\n        // The callback function should be defined.\n        if (callbackFuncInvoker === null) {\n            throw new Error(\n                `cannot call exit function '${this.functionName}' as is not defined on the agent and has not been registered`\n            );\n        }\n\n        // Call the callback function.\n        callbackFuncInvoker([{ value: { succeeded: isSuccess, aborted: isAborted } }].concat(this.args));\n    };\n}\n", "import Callback from \"./callback\";\nimport Lookup from \"../../lookup\";\n\n/**\n * A STEP callback which defines an agent function to call when the associated node is updated.\n * @param functionName The name of the agent function to call.\n * @param args The array of callback argument definitions.\n */\nexport default class Step extends Callback {\n    constructor(private functionName: string, args: any[]) {\n        super(\"exit\", args);\n    }\n\n    /**\n     * Gets the function name.\n     */\n    getFunctionName = () => this.functionName;\n\n    /**\n     * Gets the callback details.\n     */\n    getDetails = () => {\n        return {\n            type: this.getType(),\n            isGuard: this.isGuard(),\n            functionName: this.getFunctionName(),\n            arguments: this.getArguments()\n        };\n    };\n\n    /**\n     * Attempt to call the agent function that this callback refers to.\n     * @param agent The agent.\n     */\n    callAgentFunction = (agent: any) => {\n        // Attempt to get the invoker for the callback function.\n        const callbackFuncInvoker = Lookup.getFuncInvoker(agent, this.functionName);\n\n        // The callback function should be defined.\n        if (callbackFuncInvoker === null) {\n            throw new Error(\n                `cannot call step function '${this.functionName}' as is not defined on the agent and has not been registered`\n            );\n        }\n\n        // Call the callback function.\n        callbackFuncInvoker(this.args);\n    };\n}\n", "import Action from \"./nodes/leaf/action\";\nimport Condition from \"./nodes/leaf/condition\";\nimport Wait from \"./nodes/leaf/wait\";\nimport Root from \"./nodes/decorator/root\";\nimport Repeat from \"./nodes/decorator/repeat\";\nimport Retry from \"./nodes/decorator/retry\";\nimport Flip from \"./nodes/decorator/flip\";\nimport Succeed from \"./nodes/decorator/succeed\";\nimport Fail from \"./nodes/decorator/fail\";\nimport Lotto from \"./nodes/composite/lotto\";\nimport Selector from \"./nodes/composite/selector\";\nimport Sequence from \"./nodes/composite/sequence\";\nimport Parallel from \"./nodes/composite/parallel\";\nimport Node from \"./nodes/node\";\nimport While from \"./attributes/guards/while\";\nimport Until from \"./attributes/guards/until\";\nimport Entry from \"./attributes/callbacks/entry\";\nimport Exit from \"./attributes/callbacks/exit\";\nimport Step from \"./attributes/callbacks/step\";\nimport Callback from \"./attributes/callbacks/callback\";\nimport Guard from \"./attributes/guards/guard\";\n\n/**\n * The node decorator factories.\n */\nconst DecoratorFactories: {[key: string]: (functionName: string, decoratorArguments: any[]) => Callback | Guard } = {\n    WHILE: (condition: string, decoratorArguments: any[]) => new While(condition, decoratorArguments),\n    UNTIL: (condition: string, decoratorArguments: any[]) => new Until(condition, decoratorArguments),\n    ENTRY: (functionName: string, decoratorArguments: any[]) => new Entry(functionName, decoratorArguments),\n    EXIT: (functionName: string, decoratorArguments: any[]) => new Exit(functionName, decoratorArguments),\n    STEP: (functionName: string, decoratorArguments: any[]) => new Step(functionName, decoratorArguments)\n};\n\ntype NamedRootNodeProvider = (name: string) => AstNode<Root>;\ntype NodeInstanceCreator<T extends Node> = (namedRootNodeProvider: NamedRootNodeProvider, visitedBranches: any) => T;\ntype Placeholders = { [key: string]: string };\ntype ArgumentDefinition = {\n    value: string | number | boolean | null;\n    isInteger?: boolean;\n    type: string;\n    toString(): any;\n};\n// \"definitionLevelNode\"\ntype Validatable = {\n    validate: (this: any, depth: number) => void;\n    // TODO: Also this one:\n    children?: AstNode<Node>[];\n}\nexport type AstNode<T extends Node> = {\n    type: string;\n    decorators: any[];\n    createNodeInstance: NodeInstanceCreator<T>;\n    // TODO: Stuff from different kinds:\n    name?: null | string;\n    branchName?: \"\" | string;\n    tickets?: any[];\n    iterations?: number | null;\n    maximumIterations?: number | null;\n    duration?: number | null;\n    longestDuration?: number | null;\n    actionName?: string;\n    actionArguments?: any[];\n    conditionName?: string;\n    conditionArguments?: any[];\n} & Validatable;\n\n/**\n * The AST node factories.\n */\nconst ASTNodeFactories = {\n    ROOT: (): AstNode<Root> => ({\n        type: \"root\",\n        decorators: [],\n        name: null,\n        children: [],\n        validate(depth: number) {\n            // A root node cannot be the child of another node.\n            if (depth > 1) {\n                throw new Error(\"a root node cannot be the child of another node\");\n            }\n\n            // A root node must have a single child node.\n            if (this.children!.length !== 1) {\n                throw new Error(\"a root node must have a single child\");\n            }\n        },\n        createNodeInstance(namedRootNodeProvider, visitedBranches) {\n            return new Root(\n                this.decorators,\n                this.children![0].createNodeInstance(namedRootNodeProvider, visitedBranches.slice())\n            );\n        }\n    }),\n    BRANCH: (): AstNode<Node> =>\n        ({\n            type: \"branch\",\n            branchName: \"\",\n            validate() {},\n            createNodeInstance(namedRootNodeProvider: NamedRootNodeProvider, visitedBranches: any) {\n                // Try to find the root node with a matching branch name.\n                const targetRootNode = namedRootNodeProvider(this.branchName);\n\n                // If we have already visited this branch then we have a circular dependency.\n                if (visitedBranches.indexOf(this.branchName) !== -1) {\n                    throw new Error(\n                        `circular dependency found in branch node references for branch '${this.branchName}'`\n                    );\n                }\n\n                // If we have a target root node, then the node instance we want will be the first and only child of the referenced root node.\n                if (targetRootNode) {\n                    return targetRootNode\n                        .createNodeInstance(namedRootNodeProvider, visitedBranches.concat(this.branchName))\n                        .getChildren()[0];\n                } else {\n                    throw new Error(`branch references root node '${this.branchName}' which has not been defined`);\n                }\n            }\n        } as any),\n    SELECTOR: (): AstNode<Selector> => ({\n        type: \"selector\",\n        decorators: [],\n        children: [],\n        validate() {\n            // A selector node must have at least a single node.\n            if (this.children!.length < 1) {\n                throw new Error(\"a selector node must have at least a single child\");\n            }\n        },\n        createNodeInstance(namedRootNodeProvider, visitedBranches) {\n            return new Selector(\n                this.decorators,\n                this.children!.map((child) => child.createNodeInstance(namedRootNodeProvider, visitedBranches.slice()))\n            );\n        }\n    }),\n    SEQUENCE: (): AstNode<Sequence> => ({\n        type: \"sequence\",\n        decorators: [],\n        children: [],\n        validate() {\n            // A sequence node must have at least a single node.\n            if (this.children!.length < 1) {\n                throw new Error(\"a sequence node must have at least a single child\");\n            }\n        },\n        createNodeInstance(namedRootNodeProvider, visitedBranches) {\n            return new Sequence(\n                this.decorators,\n                this.children!.map((child) => child.createNodeInstance(namedRootNodeProvider, visitedBranches.slice()))\n            );\n        }\n    }),\n    PARALLEL: (): AstNode<Parallel> => ({\n        type: \"parallel\",\n        decorators: [],\n        children: [],\n        validate() {\n            // A parallel node must have at least a single node.\n            if (this.children!.length < 1) {\n                throw new Error(\"a parallel node must have at least a single child\");\n            }\n        },\n        createNodeInstance(namedRootNodeProvider, visitedBranches) {\n            return new Parallel(\n                this.decorators,\n                this.children!.map((child) => child.createNodeInstance(namedRootNodeProvider, visitedBranches.slice()))\n            );\n        }\n    }),\n    LOTTO: (): AstNode<Lotto> => ({\n        type: \"lotto\",\n        decorators: [],\n        children: [],\n        tickets: [],\n        validate() {\n            // A lotto node must have at least a single node.\n            if (this.children!.length < 1) {\n                throw new Error(\"a lotto node must have at least a single child\");\n            }\n        },\n        createNodeInstance(namedRootNodeProvider, visitedBranches) {\n            return new Lotto(\n                this.decorators,\n                this.tickets!,\n                this.children!.map((child) => child.createNodeInstance(namedRootNodeProvider, visitedBranches.slice()))\n            );\n        }\n    }),\n    REPEAT: (): AstNode<Repeat> => ({\n        type: \"repeat\",\n        decorators: [],\n        iterations: null,\n        maximumIterations: null,\n        children: [],\n        validate() {\n            // A repeat node must have a single node.\n            if (this.children!.length !== 1) {\n                throw new Error(\"a repeat node must have a single child\");\n            }\n\n            // A repeat node must have a positive number of iterations if defined.\n            if (this.iterations !== null && this.iterations! < 0) {\n                throw new Error(\"a repeat node must have a positive number of iterations if defined\");\n            }\n\n            // There is validation to carry out if a longest duration was defined.\n            if (this.maximumIterations !== null) {\n                // A repeat node must have a positive maximum iterations count if defined.\n                if (this.maximumIterations! < 0) {\n                    throw new Error(\"a repeat node must have a positive maximum iterations count if defined\");\n                }\n\n                // A repeat node must not have an iteration count that exceeds the maximum iteration count.\n                if (this.iterations! > this.maximumIterations!) {\n                    throw new Error(\n                        \"a repeat node must not have an iteration count that exceeds the maximum iteration count\"\n                    );\n                }\n            }\n        },\n        createNodeInstance(namedRootNodeProvider, visitedBranches) {\n            return new Repeat(\n                this.decorators,\n                this.iterations!,\n                this.maximumIterations!,\n                this.children![0].createNodeInstance(namedRootNodeProvider, visitedBranches.slice())\n            );\n        }\n    }),\n    RETRY: (): AstNode<Retry> => ({\n        type: \"retry\",\n        decorators: [],\n        iterations: null,\n        maximumIterations: null,\n        children: [],\n        validate() {\n            // A retry node must have a single node.\n            if (this.children!.length !== 1) {\n                throw new Error(\"a retry node must have a single child\");\n            }\n\n            // A retry node must have a positive number of iterations if defined.\n            if (this.iterations !== null && this.iterations! < 0) {\n                throw new Error(\"a retry node must have a positive number of iterations if defined\");\n            }\n\n            // There is validation to carry out if a longest duration was defined.\n            if (this.maximumIterations !== null) {\n                // A retry node must have a positive maximum iterations count if defined.\n                if (this.maximumIterations! < 0) {\n                    throw new Error(\"a retry node must have a positive maximum iterations count if defined\");\n                }\n\n                // A retry node must not have an iteration count that exceeds the maximum iteration count.\n                if (this.iterations! > this.maximumIterations!) {\n                    throw new Error(\n                        \"a retry node must not have an iteration count that exceeds the maximum iteration count\"\n                    );\n                }\n            }\n        },\n        createNodeInstance(namedRootNodeProvider, visitedBranches) {\n            return new Retry(\n                this.decorators,\n                this.iterations!,\n                this.maximumIterations!,\n                this.children![0].createNodeInstance(namedRootNodeProvider, visitedBranches.slice())\n            );\n        }\n    }),\n    FLIP: (): AstNode<Flip> => ({\n        type: \"flip\",\n        decorators: [],\n        children: [],\n        validate() {\n            // A flip node must have a single node.\n            if (this.children!.length !== 1) {\n                throw new Error(\"a flip node must have a single child\");\n            }\n        },\n        createNodeInstance(namedRootNodeProvider, visitedBranches) {\n            return new Flip(\n                this.decorators,\n                this.children![0].createNodeInstance(namedRootNodeProvider, visitedBranches.slice())\n            );\n        }\n    }),\n    SUCCEED: (): AstNode<Succeed> => ({\n        type: \"succeed\",\n        decorators: [],\n        children: [],\n        validate() {\n            // A succeed node must have a single node.\n            if (this.children!.length !== 1) {\n                throw new Error(\"a succeed node must have a single child\");\n            }\n        },\n        createNodeInstance(namedRootNodeProvider, visitedBranches) {\n            return new Succeed(\n                this.decorators,\n                this.children![0].createNodeInstance(namedRootNodeProvider, visitedBranches.slice())\n            );\n        }\n    }),\n    FAIL: (): AstNode<Fail> => ({\n        type: \"fail\",\n        decorators: [],\n        children: [],\n        validate() {\n            // A fail node must have a single node.\n            if (this.children!.length !== 1) {\n                throw new Error(\"a fail node must have a single child\");\n            }\n        },\n        createNodeInstance(namedRootNodeProvider, visitedBranches) {\n            return new Fail(\n                this.decorators,\n                this.children![0].createNodeInstance(namedRootNodeProvider, visitedBranches.slice())\n            );\n        }\n    }),\n    WAIT: (): AstNode<Wait> => ({\n        type: \"wait\",\n        decorators: [],\n        duration: null,\n        longestDuration: null,\n        validate() {\n            // A wait node must have a positive duration.\n            if (this.duration! < 0) {\n                throw new Error(\"a wait node must have a positive duration\");\n            }\n\n            // There is validation to carry out if a longest duration was defined.\n            if (this.longestDuration) {\n                // A wait node must have a positive longest duration.\n                if (this.longestDuration < 0) {\n                    throw new Error(\"a wait node must have a positive longest duration if one is defined\");\n                }\n\n                // A wait node must not have a duration that exceeds the longest duration.\n                if (this.duration! > this.longestDuration) {\n                    throw new Error(\"a wait node must not have a shortest duration that exceeds the longest duration\");\n                }\n            }\n        },\n        createNodeInstance() {\n            return new Wait(this.decorators, this.duration!, this.longestDuration!);\n        }\n    }),\n    ACTION: (): AstNode<Action> => ({\n        type: \"action\",\n        decorators: [],\n        actionName: \"\",\n        actionArguments: [],\n        validate() {},\n        createNodeInstance() {\n            return new Action(this.decorators, this.actionName!, this.actionArguments!);\n        }\n    }),\n    CONDITION: (): AstNode<Condition> => ({\n        type: \"condition\",\n        decorators: [],\n        conditionName: \"\",\n        conditionArguments: [],\n        validate() {},\n        createNodeInstance() {\n            return new Condition(this.decorators, this.conditionName!, this.conditionArguments!);\n        }\n    })\n};\n\n/**\n * Create an array of root AST nodes based on the given definition.\n * @param definition The definition to parse the AST nodes from.\n * @returns The base definition AST nodes.\n */\nexport default function buildRootASTNodes(definition: string): AstNode<Root>[] {\n    // Swap out any node/decorator argument string literals with a placeholder and get a mapping of placeholders to original values as well as the processed definition.\n    const { placeholders, processedDefinition } = substituteStringLiterals(definition);\n\n    // Convert the processed definition (with substituted string literals) into an array of raw tokens.\n    const tokens = parseTokensFromDefinition(processedDefinition);\n\n    // There must be at least 3 tokens for the tree definition to be valid. 'ROOT', '{' and '}'.\n    if (tokens.length < 3) {\n        throw new Error(\"invalid token count\");\n    }\n\n    // We should have a matching number of '{' and '}' tokens. If not, then there are scopes that have not been properly closed.\n    if (tokens.filter((token) => token === \"{\").length !== tokens.filter((token) => token === \"}\").length) {\n        throw new Error(\"scope character mismatch\");\n    }\n\n    // Create a stack of node children arrays, starting with a definition scope.\n    const stack: AstNode<Node>[][] = [[]];\n\n    // We should keep processing the raw tokens until we run out of them.\n    while (tokens.length) {\n        // Grab the next token.\n        const token = tokens.shift();\n\n        let node;\n\n        // How we create the next AST token depends on the current raw token value.\n        switch (token!.toUpperCase()) {\n            case \"ROOT\":\n                // Create a ROOT AST node.\n                node = ASTNodeFactories.ROOT();\n\n                // Push the ROOT node into the current scope.\n                stack[stack.length - 1].push(node);\n\n                // We may have a root node name defined as an argument.\n                if (tokens[0] === \"[\") {\n                    const rootArguments = getArguments(tokens, placeholders);\n\n                    // We should have only a single argument that is not an empty string for a root node, which is the root name identifier.\n                    if (rootArguments.length === 1 && rootArguments[0].type === \"identifier\") {\n                        // The root name will be the first and only node argument.\n                        node.name = rootArguments[0].value as string;\n                    } else {\n                        throw new Error(\"expected single root name argument\");\n                    }\n                }\n\n                // Try to pick any decorators off of the token stack.\n                node.decorators = getDecorators(tokens, placeholders);\n\n                popAndCheck(tokens, \"{\");\n\n                // The new scope is that of the new ROOT nodes children.\n                stack.push(node.children!);\n                break;\n\n            case \"BRANCH\":\n                // Create a BRANCH AST node.\n                node = ASTNodeFactories.BRANCH();\n\n                // Push the BRANCH node into the current scope.\n                stack[stack.length - 1].push(node);\n\n                // We must have arguments defined, as we require a branch name argument.\n                if (tokens[0] !== \"[\") {\n                    throw new Error(\"expected single branch name argument\");\n                }\n\n                // The branch name will be defined as a node argument.\n                const branchArguments = getArguments(tokens, placeholders);\n\n                // We should have only a single identifer argument for a branch node, which is the branch name.\n                if (branchArguments.length === 1 && branchArguments[0].type === \"identifier\") {\n                    // The branch name will be the first and only node argument.\n                    node.branchName = branchArguments[0].value as string;\n                } else {\n                    throw new Error(\"expected single branch name argument\");\n                }\n                break;\n\n            case \"SELECTOR\":\n                // Create a SELECTOR AST node.\n                node = ASTNodeFactories.SELECTOR();\n\n                // Push the SELECTOR node into the current scope.\n                stack[stack.length - 1].push(node);\n\n                // Try to pick any decorators off of the token stack.\n                node.decorators = getDecorators(tokens, placeholders);\n\n                popAndCheck(tokens, \"{\");\n\n                // The new scope is that of the new SELECTOR nodes children.\n                stack.push(node.children!);\n                break;\n\n            case \"SEQUENCE\":\n                // Create a SEQUENCE AST node.\n                node = ASTNodeFactories.SEQUENCE();\n\n                // Push the SEQUENCE node into the current scope.\n                stack[stack.length - 1].push(node);\n\n                // Try to pick any decorators off of the token stack.\n                node.decorators = getDecorators(tokens, placeholders);\n\n                popAndCheck(tokens, \"{\");\n\n                // The new scope is that of the new SEQUENCE nodes children.\n                stack.push(node.children!);\n                break;\n\n            case \"PARALLEL\":\n                // Create a PARALLEL AST node.\n                node = ASTNodeFactories.PARALLEL();\n\n                // Push the PARALLEL node into the current scope.\n                stack[stack.length - 1].push(node);\n\n                // Try to pick any decorators off of the token stack.\n                node.decorators = getDecorators(tokens, placeholders);\n\n                popAndCheck(tokens, \"{\");\n\n                // The new scope is that of the new PARALLEL nodes children.\n                stack.push(node.children!);\n                break;\n\n            case \"LOTTO\":\n                // Create a LOTTO AST node.\n                node = ASTNodeFactories.LOTTO();\n\n                // Push the LOTTO node into the current scope.\n                stack[stack.length - 1].push(node);\n\n                // If the next token is a '[' character then some ticket counts have been defined as arguments.\n                if (tokens[0] === \"[\") {\n                    // Get the ticket count arguments, each argument must be a number.\n                    node.tickets = getArguments(\n                        tokens,\n                        placeholders,\n                        (arg) => arg.type === \"number\" && !!arg.isInteger,\n                        \"lotto node ticket counts must be integer values\"\n                    ).map((argument) => argument.value);\n                }\n\n                // Try to pick any decorators off of the token stack.\n                node.decorators = getDecorators(tokens, placeholders);\n\n                popAndCheck(tokens, \"{\");\n\n                // The new scope is that of the new LOTTO nodes children.\n                stack.push(node.children!);\n                break;\n\n            case \"CONDITION\":\n                // Create a CONDITION AST node.\n                node = ASTNodeFactories.CONDITION();\n\n                // Push the CONDITION node into the current scope.\n                stack[stack.length - 1].push(node);\n\n                // We must have arguments defined, as we require a condition function name argument.\n                if (tokens[0] !== \"[\") {\n                    throw new Error(\"expected condition name identifier argument\");\n                }\n\n                // Grab the condition node arguments.\n                const conditionArguments = getArguments(tokens, placeholders);\n\n                // We should have at least a single identifier argument for a condition node, which is the condition function name.\n                if (conditionArguments.length && conditionArguments[0].type === \"identifier\") {\n                    // The condition function name will be the first node argument.\n                    node.conditionName = conditionArguments.shift()!.value as string;\n                } else {\n                    throw new Error(\"expected condition name identifier argument\");\n                }\n\n                // Only the first argument should have been an identifier, all following arguments must be string, number, boolean or null.\n                conditionArguments\n                    .filter((arg) => arg.type === \"identifier\")\n                    .forEach((arg) => {\n                        throw new Error(\n                            \"invalid condition node argument value '\" +\n                                arg.value +\n                                \"', must be string, number, boolean or null\"\n                        );\n                    });\n\n                // Any node arguments that follow the condition name identifier will be treated as condition function arguments.\n                node.conditionArguments = conditionArguments;\n\n                // Try to pick any decorators off of the token stack.\n                node.decorators = getDecorators(tokens, placeholders);\n                break;\n\n            case \"FLIP\":\n                // Create a FLIP AST node.\n                node = ASTNodeFactories.FLIP();\n\n                // Push the Flip node into the current scope.\n                stack[stack.length - 1].push(node);\n\n                // Try to pick any decorators off of the token stack.\n                node.decorators = getDecorators(tokens, placeholders);\n\n                popAndCheck(tokens, \"{\");\n\n                // The new scope is that of the new FLIP nodes children.\n                stack.push(node.children!);\n                break;\n\n            case \"SUCCEED\":\n                // Create a SUCCEED AST node.\n                node = ASTNodeFactories.SUCCEED();\n\n                // Push the Succeed node into the current scope.\n                stack[stack.length - 1].push(node);\n\n                // Try to pick any decorators off of the token stack.\n                node.decorators = getDecorators(tokens, placeholders);\n\n                popAndCheck(tokens, \"{\");\n\n                // The new scope is that of the new Succeed nodes children.\n                stack.push(node.children!);\n                break;\n\n            case \"FAIL\":\n                // Create a FAIL AST node.\n                node = ASTNodeFactories.FAIL();\n\n                // Push the Fail node into the current scope.\n                stack[stack.length - 1].push(node);\n\n                // Try to pick any decorators off of the token stack.\n                node.decorators = getDecorators(tokens, placeholders);\n\n                popAndCheck(tokens, \"{\");\n\n                // The new scope is that of the new Fail nodes children.\n                stack.push(node.children!);\n                break;\n\n            case \"WAIT\":\n                // Create a WAIT AST node.\n                node = ASTNodeFactories.WAIT();\n\n                // Push the WAIT node into the current scope.\n                stack[stack.length - 1].push(node);\n\n                // Get the duration and potential longest duration of the wait.\n                const durations = getArguments(\n                    tokens,\n                    placeholders,\n                    (arg) => arg.type === \"number\" && !!arg.isInteger,\n                    \"wait node durations must be integer values\"\n                ).map((argument) => argument.value);\n\n                // We should have got one or two durations.\n                if (durations.length === 1) {\n                    // A static duration was defined.\n                    node.duration = durations[0] as number;\n                } else if (durations.length === 2) {\n                    // A shortest and longest duration was defined.\n                    node.duration = durations[0] as number;\n                    node.longestDuration = durations[1] as number;\n                } else {\n                    // An incorrect number of durations was defined.\n                    throw new Error(\"invalid number of wait node duration arguments defined\");\n                }\n\n                // Try to pick any decorators off of the token stack.\n                node.decorators = getDecorators(tokens, placeholders);\n                break;\n\n            case \"REPEAT\":\n                // Create a REPEAT AST node.\n                node = ASTNodeFactories.REPEAT();\n\n                // Push the REPEAT node into the current scope.\n                stack[stack.length - 1].push(node);\n\n                // Check for iteration counts ([])\n                if (tokens[0] === \"[\") {\n                    // An iteration count has been defined. Get the iteration and potential maximum iteration of the wait.\n                    const iterationArguments = getArguments(\n                        tokens,\n                        placeholders,\n                        (arg) => arg.type === \"number\" && !!arg.isInteger,\n                        \"repeat node iteration counts must be integer values\"\n                    ).map((argument) => argument.value);\n\n                    // We should have got one or two iteration counts.\n                    if (iterationArguments.length === 1) {\n                        // A static iteration count was defined.\n                        node.iterations = iterationArguments[0] as number;\n                    } else if (iterationArguments.length === 2) {\n                        // A minimum and maximum iteration count was defined.\n                        node.iterations = iterationArguments[0] as number;\n                        node.maximumIterations = iterationArguments[1] as number;\n                    } else {\n                        // An incorrect number of iteration counts was defined.\n                        throw new Error(\"invalid number of repeat node iteration count arguments defined\");\n                    }\n                }\n\n                // Try to pick any decorators off of the token stack.\n                node.decorators = getDecorators(tokens, placeholders);\n\n                popAndCheck(tokens, \"{\");\n\n                // The new scope is that of the new REPEAT nodes children.\n                stack.push(node.children!);\n                break;\n\n            case \"RETRY\":\n                // Create a RETRY AST node.\n                node = ASTNodeFactories.RETRY();\n\n                // Push the RETRY node into the current scope.\n                stack[stack.length - 1].push(node);\n\n                // Check for iteration counts ([])\n                if (tokens[0] === \"[\") {\n                    // An iteration count has been defined. Get the iteration and potential maximum iteration of the wait.\n                    const iterationArguments = getArguments(\n                        tokens,\n                        placeholders,\n                        (arg) => arg.type === \"number\" && !!arg.isInteger,\n                        \"retry node iteration counts must be integer values\"\n                    ).map((argument) => argument.value);\n\n                    // We should have got one or two iteration counts.\n                    if (iterationArguments.length === 1) {\n                        // A static iteration count was defined.\n                        node.iterations = iterationArguments[0] as number;\n                    } else if (iterationArguments.length === 2) {\n                        // A minimum and maximum iteration count was defined.\n                        node.iterations = iterationArguments[0] as number;\n                        node.maximumIterations = iterationArguments[1] as number;\n                    } else {\n                        // An incorrect number of iteration counts was defined.\n                        throw new Error(\"invalid number of retry node iteration count arguments defined\");\n                    }\n                }\n\n                // Try to pick any decorators off of the token stack.\n                node.decorators = getDecorators(tokens, placeholders);\n\n                popAndCheck(tokens, \"{\");\n\n                // The new scope is that of the new RETRY nodes children.\n                stack.push(node.children!);\n                break;\n\n            case \"ACTION\":\n                // Create a ACTION AST node.\n                node = ASTNodeFactories.ACTION();\n\n                // Push the ACTION node into the current scope.\n                stack[stack.length - 1].push(node);\n\n                // We must have arguments defined, as we require an action name argument.\n                if (tokens[0] !== \"[\") {\n                    throw new Error(\"expected action name identifier argument\");\n                }\n\n                // The action name will be defined as a node argument.\n                const actionArguments = getArguments(tokens, placeholders);\n\n                // We should have at least one identifer argument for an action node, which is the action name.\n                if (actionArguments.length && actionArguments[0].type === \"identifier\") {\n                    // The action name will be the first and only node argument.\n                    node.actionName = actionArguments.shift()!.value as string;\n                } else {\n                    throw new Error(\"expected action name identifier argument\");\n                }\n\n                // Only the first argument should have been an identifier, all following arguments must be string, number, boolean or null.\n                actionArguments\n                    .filter((arg) => arg.type === \"identifier\")\n                    .forEach((arg) => {\n                        throw new Error(\n                            \"invalid action node argument value '\" +\n                                arg.value +\n                                \"', must be string, number, boolean or null\"\n                        );\n                    });\n\n                // Any node arguments that follow the action name identifier will be treated as action function arguments.\n                node.actionArguments = actionArguments;\n\n                // Try to pick any decorators off of the token stack.\n                node.decorators = getDecorators(tokens, placeholders);\n                break;\n\n            case \"}\":\n                // The '}' character closes the current scope.\n                stack.pop();\n                break;\n\n            default:\n                throw new Error(\"unexpected token: \" + token);\n        }\n    }\n\n    // A function to recursively validate each of the nodes in the AST.\n    const validateASTNode = (node: Validatable, depth: number): void => {\n        // Validate the node.\n        node.validate(depth);\n\n        // Validate each child of the node.\n        (node.children || []).forEach((child) => validateASTNode(child, depth + 1));\n    };\n\n    // Start node validation from the definition root.\n    validateASTNode(\n        {\n            children: stack[0],\n            validate(depth) {\n                // We must have at least one node defined as the definition scope, which should be a root node.\n                if (this.children.length === 0) {\n                    throw new Error(\"expected root node to have been defined\");\n                }\n\n                // Each node at the base of the definition scope MUST be a root node.\n                for (const definitionLevelNode of this.children) {\n                    if (definitionLevelNode.type !== \"root\") {\n                        throw new Error(\"expected root node at base of definition\");\n                    }\n                }\n\n                // Exactly one root node must not have a name defined. This will be the main root, others will have to be referenced via branch nodes.\n                if (\n                    this.children.filter(function (definitionLevelNode: AstNode<Node>) {\n                        return definitionLevelNode.name === null;\n                    }).length !== 1\n                ) {\n                    throw new Error(\"expected single unnamed root node at base of definition to act as main root\");\n                }\n\n                // No two named root nodes can have matching names.\n                const rootNodeNames = [];\n                for (const definitionLevelNode of this.children) {\n                    if (rootNodeNames.indexOf(definitionLevelNode.name) !== -1) {\n                        throw new Error(`multiple root nodes found with duplicate name '${definitionLevelNode.name}'`);\n                    } else {\n                        rootNodeNames.push(definitionLevelNode.name);\n                    }\n                }\n            }\n        },\n        0\n    );\n\n    // Return the root AST nodes.\n    return stack[0] as AstNode<Root>[];\n}\n\n/**\n * Pop the next raw token off of the stack and throw an error if it wasn't the expected one.\n * @param tokens The array of remaining tokens.\n * @param expected An optional string or array or items, one of which must match the next popped token.\n * @returns The popped token.\n */\nfunction popAndCheck(tokens: string[], expected: string | string[]) {\n    // Get and remove the next token.\n    const popped = tokens.shift();\n\n    // We were expecting another token.\n    if (popped === undefined) {\n        throw new Error(\"unexpected end of definition\");\n    }\n\n    // Do we have an expected token/tokens array?\n    if (expected !== undefined) {\n        // Check whether the popped token matches at least one of our expected items.\n        var tokenMatchesExpectation = ([] as string[]).concat(expected).some((item) => popped.toUpperCase() === item.toUpperCase());\n\n        // Throw an error if the popped token didn't match any of our expected items.\n        if (!tokenMatchesExpectation) {\n            const expectationString = ([] as string[])\n                .concat(expected)\n                .map((item) => \"'\" + item + \"'\")\n                .join(\" or \");\n            throw new Error(\"unexpected token found. Expected \" + expectationString + \" but got '\" + popped + \"'\");\n        }\n    }\n\n    // Return the popped token.\n    return popped;\n}\n\n/**\n * Pull an argument definition list off of the token stack.\n * @param tokens The array of remaining tokens.\n * @param stringArgumentPlaceholders The mapping of string literal node argument placeholders to original values.\n * @param argumentValidator The argument validator function.\n * @param validationFailedMessage  The exception message to throw if argument validation fails.\n * @returns The argument definition list.\n */\nfunction getArguments(\n    tokens: string[],\n    stringArgumentPlaceholders: Placeholders,\n    argumentValidator?: (arg: ArgumentDefinition) => boolean,\n    validationFailedMessage?: string\n) {\n    // Any lists of arguments will always be wrapped in '[]' for node arguments or '()' for decorator arguments.\n    // We are looking for a '[' or '(' opener that wraps the argument tokens and the relevant closer.\n    const closer = popAndCheck(tokens, [\"[\", \"(\"]) === \"[\" ? \"]\" : \")\";\n\n    const argumentListTokens = [];\n    const argumentList: ArgumentDefinition[] = [];\n\n    // Grab all tokens between the '[' and ']' or '(' and ')'.\n    while (tokens.length && tokens[0] !== closer) {\n        // The next token is part of our arguments list.\n        argumentListTokens.push(tokens.shift());\n    }\n\n    // Validate the order of the argument tokens. Each token must either be a ',' or a single argument that satisfies the validator.\n    argumentListTokens.forEach((token, index) => {\n        // Get whether this token should be an actual argument.\n        const shouldBeArgumentToken = !(index & 1);\n\n        // If the current token should be an actual argument then validate it,otherwise it should be a ',' token.\n        if (shouldBeArgumentToken) {\n            // Get the argument definition.\n            const argumentDefinition = getArgumentDefinition(token!, stringArgumentPlaceholders);\n\n            // Try to validate the argument.\n            if (argumentValidator && !argumentValidator(argumentDefinition)) {\n                throw new Error(validationFailedMessage);\n            }\n\n            // This is a valid argument!\n            argumentList.push(argumentDefinition);\n        } else {\n            // The current token should be a ',' token.\n            if (token !== \",\") {\n                throw new Error(`invalid argument list, expected ',' or ']' but got '${token}'`);\n            }\n        }\n    });\n\n    // The arguments list should terminate with a ']' or ')' token, depending on the opener.\n    popAndCheck(tokens, closer);\n\n    // Return the argument list.\n    return argumentList;\n}\n\n/**\n * Gets an argument value definition.\n * @param token The argument token.\n * @param stringArgumentPlaceholders The mapping of string literal node argument placeholders to original values.\n * @returns An argument value definition.\n */\nfunction getArgumentDefinition(token: string, stringArgumentPlaceholders: Placeholders): ArgumentDefinition {\n    // Check whether the token represents a null value.\n    if (token === \"null\") {\n        return {\n            value: null,\n            type: \"null\",\n            toString() {\n                return this.value;\n            }\n        };\n    }\n\n    // Check whether the token represents a boolean value.\n    if (token === \"true\" || token === \"false\") {\n        return {\n            value: token === \"true\",\n            type: \"boolean\",\n            toString() {\n                return this.value;\n            }\n        };\n    }\n\n    // Check whether the token represents a number value.\n    if (!isNaN(token as any)) {\n        return {\n            value: parseFloat(token),\n            isInteger: parseFloat(token) === parseInt(token, 10),\n            type: \"number\",\n            toString() {\n                return this.value;\n            }\n        };\n    }\n\n    // Check whether the token is a placeholder (e.g. @@0@@) representing a string literal.\n    if (token.match(/^@@\\d+@@$/g)) {\n        return {\n            value: stringArgumentPlaceholders[token].replace('\\\\\"', '\"'),\n            type: \"string\",\n            toString() {\n                return '\"' + this.value + '\"';\n            }\n        };\n    }\n\n    // The only remaining option is that the argument value is an identifier.\n    return {\n        value: token,\n        type: \"identifier\",\n        toString() {\n            return this.value;\n        }\n    };\n}\n\n/**\n * Pull any decorators off of the token stack.\n * @param tokens The array of remaining tokens.\n * @param stringArgumentPlaceholders The mapping of string literal node argument placeholders to original values.\n * @returns An array od decorators defined by any directly following tokens.\n */\nfunction getDecorators(tokens: string[], stringArgumentPlaceholders: Placeholders) {\n    // Create an array to hold any decorators found.\n    const decorators = [];\n\n    // Keep track of names of decorators that we have found on the token stack, as we cannot have duplicates.\n    const decoratorsFound = [];\n\n    // Try to get the decorator factory for the next token.\n    let decoratorFactory = DecoratorFactories[(tokens[0] || \"\").toUpperCase()];\n\n    // Pull decorator tokens off of the tokens stack until we have no more.\n    while (decoratorFactory) {\n        // Check to make sure that we have not already created a decorator of this type for this node.\n        if (decoratorsFound.indexOf(tokens[0].toUpperCase()) !== -1) {\n            throw new Error(`duplicate decorator '${tokens[0].toUpperCase()}' found for node`);\n        }\n\n        // Add the current decorator type to our array of found decorators.\n        decoratorsFound.push(tokens.shift()!.toUpperCase());\n\n        // Grab any decorator arguments.\n        const decoratorArguments = getArguments(tokens, stringArgumentPlaceholders);\n\n        // The first decorator argument has to be an identifer, this will reference an agent function.\n        if (decoratorArguments.length === 0 || decoratorArguments[0].type !== \"identifier\") {\n            throw new Error(\"expected agent function name identifier argument for decorator\");\n        }\n\n        // Grab the first decorator which is an identifier that will reference an agent function.\n        const decoratorFunctionName = decoratorArguments.shift()!;\n\n        // Any remaining decorator arguments must have a type of string, number, boolean or null.\n        decoratorArguments\n            .filter((arg) => arg.type === \"identifier\")\n            .forEach((arg) => {\n                throw new Error(\n                    \"invalid decorator argument value '\" + arg.value + \"', must be string, number, boolean or null\"\n                );\n            });\n\n        // Create the decorator and add it to the array of decorators found.\n        decorators.push(decoratorFactory(decoratorFunctionName as any, decoratorArguments));\n\n        // Try to get the next decorator name token, as there could be multiple.\n        decoratorFactory = DecoratorFactories[(tokens[0] || \"\").toUpperCase()];\n    }\n\n    return decorators;\n}\n\n/**\n * Swaps out any node/decorator argument string literals with placeholders.\n * @param definition The definition.\n * @returns An object containing a mapping of placeholders to original string values as well as the processed definition string.\n */\nfunction substituteStringLiterals(definition: string): {\n    placeholders: { [key: string]: string };\n    processedDefinition: string;\n} {\n    // Create an object to hold the mapping of placeholders to original string values.\n    const placeholders: Placeholders = {};\n\n    // Replace any string literals wrapped with double quotes in our definition with placeholders to be processed later.\n    const processedDefinition = definition.replace(/\\\"(\\\\.|[^\"\\\\])*\\\"/g, (match) => {\n        var strippedMatch = match.substring(1, match.length - 1);\n        var placeholder = Object.keys(placeholders).find((key) => placeholders[key] === strippedMatch);\n\n        // If we have no existing string literal match then create a new placeholder.\n        if (!placeholder) {\n            placeholder = `@@${Object.keys(placeholders).length}@@`;\n            placeholders[placeholder] = strippedMatch;\n        }\n\n        return placeholder;\n    });\n\n    return { placeholders, processedDefinition };\n}\n\n/**\n * Parse the tree definition into an array of raw tokens.\n * @param definition The definition.\n * @returns An array of tokens parsed from the definition.\n */\nfunction parseTokensFromDefinition(definition: string): string[] {\n    // Add some space around various important characters so that they can be plucked out easier as individual tokens.\n    definition = definition.replace(/\\(/g, \" ( \");\n    definition = definition.replace(/\\)/g, \" ) \");\n    definition = definition.replace(/\\{/g, \" { \");\n    definition = definition.replace(/\\}/g, \" } \");\n    definition = definition.replace(/\\]/g, \" ] \");\n    definition = definition.replace(/\\[/g, \" [ \");\n    definition = definition.replace(/\\,/g, \" , \");\n\n    // Split the definition into raw token form and return it.\n    return definition.replace(/\\s+/g, \" \").trim().split(\" \");\n}\n", "import GuardPath from \"./attributes/guards/guardPath\";\nimport buildRootASTNodes, { AstNode } from \"./rootAstNodesBuilder\";\nimport State from \"./state\";\nimport Lookup from \"./lookup\";\nimport Node from \"./nodes/node\";\nimport Root from \"./nodes/decorator/root\";\nimport Composite from \"./nodes/composite/composite\";\nimport Decorator from \"./nodes/decorator/decorator\";\n\ntype FlattenedTreeNode = {\n    id: string,\n    type: string,\n    caption: string,\n    state: any,\n    decorators: any[] | null,\n    arguments: any[],\n    parentId: string | null\n}\n\n/**\n * A representation of a behaviour tree.\n */\nexport default class BehaviourTree {\n    /**\n     * The main root tree node.\n     */\n    public readonly rootNode: Root;\n\n    /**\n     * Creates a new instance of the BehaviourTree class.\n     * @param definition The behaviour tree definition.\n     * @param agent The agent instance that this behaviour tree is modelling behaviour for.\n     */\n    constructor(definition: string, private agent: any) {\n        // The tree definition must be defined and a valid string.\n        if (typeof definition !== \"string\") {\n            throw new Error(\"the tree definition must be a string\");\n        }\n\n        // The agent must be defined and not null.\n        if (typeof agent !== \"object\" || agent === null) {\n            throw new Error(\"the agent must be defined and not null\");\n        }\n\n        // Parse the behaviour tree definition, create the populated tree of behaviour tree nodes, and get the root.\n        this.rootNode = BehaviourTree.createRootNode(definition);\n    }\n\n    /**\n     * Gets whether the tree is in the RUNNING state.\n     * @returns true if the tree is in the RUNNING state, otherwise false.\n     */\n    isRunning() {\n        return this.rootNode.getState() === State.RUNNING;\n    }\n\n    /**\n     * Gets the current tree state of SUCCEEDED, FAILED, READY or RUNNING.\n     * @returns The current tree state.\n     */\n    getState() {\n        return this.rootNode.getState();\n    }\n\n    /**\n     * Step the tree.\n     * Carries out a node update that traverses the tree from the root node outwards to any child nodes, skipping those that are already in a resolved state of SUCCEEDED or FAILED.\n     * After being updated, leaf nodes will have a state of SUCCEEDED, FAILED or RUNNING. Leaf nodes that are left in the RUNNING state as part of a tree step will be revisited each\n     * subsequent step until they move into a resolved state of either SUCCEEDED or FAILED, after which execution will move through the tree to the next node with a state of READY.\n     *\n     * Calling this method when the tree is already in a resolved state of SUCCEEDED or FAILED will cause it to be reset before tree traversal begins.\n     */\n    step() {\n        // If the root node has already been stepped to completion then we need to reset it.\n        if (this.rootNode.getState() === State.SUCCEEDED || this.rootNode.getState() === State.FAILED) {\n            this.rootNode.reset();\n        }\n\n        try {\n            this.rootNode.update(this.agent);\n        } catch (exception) {\n            throw new Error(`error stepping tree: ${(exception as Error).message}`);\n        }\n    }\n\n    /**\n     * Resets the tree from the root node outwards to each nested node, giving each a state of READY.\n     */\n    reset() {\n        this.rootNode.reset();\n    }\n\n    /**\n     * Gets the flattened details of every node in the tree.\n     * @returns The flattened details of every node in the tree.\n     */\n    getFlattenedNodeDetails(): FlattenedTreeNode[] {\n        // Create an empty flattened array of tree nodes.\n        const flattenedTreeNodes: FlattenedTreeNode[] = [];\n\n        /**\n         * Helper function to process a node instance and push details into the flattened tree nodes array.\n         * @param node The current node.\n         * @param parentUid The UID of the node parent, or null if the node is the main root node.\n         */\n        const processNode = (node: Node, parentUid: string | null) => {\n            /**\n             * Helper function to get details for all node decorators.\n             * @param decorators The node decorators.\n             * @returns The decorator details for a node.\n             */\n            const getDecoratorDetails = (decorators: Decorator[]): any[] | null =>\n                decorators.length > 0 ? decorators.map((decorator) => (decorator as any).getDetails()) : null;\n\n            // Push the current node into the flattened nodes array.\n            flattenedTreeNodes.push({\n                id: node.getUid(),\n                type: node.getType(),\n                caption: node.getName(),\n                state: node.getState(),\n                decorators: getDecoratorDetails(node.getDecorators()),\n                arguments: node.getArguments(),\n                parentId: parentUid\n            });\n\n            // Process each of the nodes children if it is not a leaf node.\n            if (!node.isLeafNode()) {\n                (node as Composite | Decorator).getChildren().forEach((child) => processNode(child, (node as Composite | Decorator).getUid()));\n            }\n        };\n\n        // Convert the nested node structure into a flattened array of node details.\n        processNode(this.rootNode, null);\n\n        return flattenedTreeNodes;\n    }\n\n    /**\n     * Registers the action/condition/guard/callback function or subtree with the given name.\n     * @param name The name of the function or subtree to register.\n     * @param value The function or subtree definition to register.\n     */\n    static register(name: string, value: Function | string) {\n        if (typeof value === \"function\") {\n            // We are going to register a action/condition/guard/callback function.\n            Lookup.setFunc(name, value);\n        } else if (typeof value === \"string\") {\n            // We are going to register a subtree.\n            let rootASTNodes;\n\n            try {\n                // Try to create the behaviour tree AST based on the definition provided, this could fail if the definition is invalid.\n                rootASTNodes = buildRootASTNodes(value);\n            } catch (exception) {\n                // There was an issue in trying to parse and build the tree definition.\n                throw new Error(`error registering definition: ${(exception as Error).message}`);\n            }\n\n            // This function should only ever be called with a definition containing a single unnamed root node.\n            if (rootASTNodes.length != 1 || rootASTNodes[0].name !== null) {\n                throw new Error(\"error registering definition: expected a single unnamed root node\");\n            }\n\n            Lookup.setSubtree(name, rootASTNodes[0]);\n        } else {\n            throw new Error(\"unexpected value, expected string definition or function\");\n        }\n    }\n\n    /**\n     * Unregisters the registered action/condition/guard/callback function or subtree with the given name.\n     * @param name The name of the registered action/condition/guard/callback function or subtree to unregister.\n     */\n    static unregister(name: string): void {\n        Lookup.remove(name);\n    }\n\n    /**\n     * Unregister all registered action/condition/guard/callback functions and subtrees.\n     */\n    static unregisterAll(): void {\n        Lookup.empty();\n    }\n\n    /**\n     * Parses a behaviour tree definition and creates a tree of behaviour tree nodes.\n     * @param {string} definition The behaviour tree definition.\n     * @returns The root behaviour tree node.\n     */\n    private static createRootNode(definition: string): Root {\n        try {\n            // Try to create the behaviour tree AST based on the definition provided, this could fail if the definition is invalid.\n            const rootASTNodes = buildRootASTNodes(definition);\n\n            // Create a symbol to use as the main root key in our root node mapping.\n            const mainRootNodeKey = Symbol(\"__root__\");\n\n            // Create a mapping of root node names to root AST tokens. The main root node will have a key of Symbol(\"__root__\").\n            const rootNodeMap: {[key: string | symbol]: AstNode<Root>} = {};\n            for (const rootASTNode of rootASTNodes) {\n                rootNodeMap[rootASTNode.name === null ? mainRootNodeKey : rootASTNode.name!] = rootASTNode;\n            }\n\n            // Create a provider for named root nodes that are part of our definition or have been registered. Prioritising the former.\n            const namedRootNodeProvider = function (name: string) {\n                return rootNodeMap[name] ? rootNodeMap[name] : Lookup.getSubtree(name);\n            };\n\n            // Convert the AST to our actual tree and get the root node.\n            const rootNode = rootNodeMap[mainRootNodeKey].createNodeInstance(namedRootNodeProvider, []);\n\n            // Set a guard path on every leaf of the tree to evaluate as part of its update.\n            BehaviourTree.applyLeafNodeGuardPaths(rootNode as any);\n\n            // Return the root node.\n            return rootNode;\n        } catch (exception) {\n            // There was an issue in trying to parse and build the tree definition.\n            throw new Error(`error parsing tree: ${(exception as Error).message}\\n${(exception as Error).stack}`);\n        }\n    }\n\n    /**\n     * Applies a guard path to every leaf of the tree to evaluate as part of each update.\n     * @param rootNode The main root tree node.\n     */\n    private static applyLeafNodeGuardPaths(rootNode: Root) {\n        const nodePaths: Node[][] = [];\n\n        const findLeafNodes = (path: Node[], node: Node) => {\n            // Add the current node to the path.\n            path = path.concat(node);\n\n            // Check whether the current node is a leaf node.\n            if (node.isLeafNode()) {\n                nodePaths.push(path);\n            } else {\n                (node as Composite | Decorator).getChildren().forEach((child) => findLeafNodes(path, child));\n            }\n        };\n\n        // Find all leaf node paths, starting from the root.\n        findLeafNodes([], rootNode);\n\n        nodePaths.forEach((path) => {\n            // Each node in the current path will have to be assigned a guard path, working from the root outwards.\n            for (let depth = 0; depth < path.length; depth++) {\n                // Get the node in the path at the current depth.\n                const currentNode = path[depth];\n\n                // The node may already have been assigned a guard path, if so just skip it.\n                if (currentNode.hasGuardPath()) {\n                    continue;\n                }\n\n                // Create the guard path for the current node.\n                const guardPath = new GuardPath(\n                    path\n                        .slice(0, depth + 1)\n                        .map((node) => ({ node, guards: node.getGuardDecorators() }))\n                        .filter((details) => details.guards.length > 0)\n                );\n\n                // Assign the guard path to the current node.\n                currentNode.setGuardPath(guardPath);\n            }\n        });\n    }\n}\n"],
  "mappings": "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",
  "names": []
}
